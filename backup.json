{       
	"Add-ADTEdgeExtension": {
		"prefix": "addedgeextension",
		"body": [
			"# Native: New-Item + Set-ItemProperty (JSON in HKLM:\\SOFTWARE\\Policies\\...\\Edge\\ExtensionSettings)",
			"<#",
			"  Verwendung: Edge-Extensions zentral per Policy verwalten und automatisch installieren",
			"  KRITISCH: Nicht zusammen mit Edge Management Service verwenden!",
			"  Beide nutzen denselben Registry-Key. InstallationMode: force_installed (erzwingt Installation)",
			"#>",
			"Add-ADTEdgeExtension `",
			"    -ExtensionID \"${1:extensionID}\" `",
			"    -InstallationMode ${2|force_installed,normal_installed,allowed,blocked,removed|} `",
			"    -UpdateUrl \"${3:https://edge.microsoft.com/extensionwebstorebase/v1/crx}\" `",
			"    -MinimumVersionRequired \"${4:1.0.0}\"$0"
		],
		"description": "Fügt eine Microsoft Edge Extension über ExtensionSettings-Policy hinzu"
	},
	"Add-ADTModuleCallback": {
		"prefix": "addmodulecallback",
		"body": [
			"# Native: Keine direkte Alternative - Event-basiertes Hook-System",
			"<#",
			"  Verwendung: Eigene Funktionen an bestimmten Punkten im Deployment-Lifecycle ausführen",
			"  KRITISCH: Callbacks werden in der Reihenfolge ihrer Registrierung ausgeführt!",
			"  Hookpoints: OnInit, OnStart, PreOpen, PostOpen, PreClose, PostClose, OnFinish, OnExit",
			"  Verwende Get-ADTModuleCallback um alle registrierten Callbacks anzuzeigen",
			"#>",
			"Add-ADTModuleCallback -Hookpoint ${1|OnInit,OnStart,PreOpen,PostOpen,PreClose,PostClose,OnFinish,OnExit|} -Callback (Get-Command -Name '${2:MyCallbackFunction}')$0"
		],
		"description": "Fügt eine Callback-Funktion zu einem bestimmten Hook-Point hinzu"
	},
	"Block-ADTAppExecution": {
		"prefix": "blockappexecution",
		"body": [
			"# Native: New-Item + Set-ItemProperty (IFEO Debugger-Key: HKLM:\\SOFTWARE\\...\\Image File Execution Options\\{exe})",
			"<#",
			"  Verwendung: Verhindert Start von Anwendungen während Installation (z.B. Office während Office-Update)",
			"  KRITISCH: Erstellt automatisch Scheduled Task zur Bereinigung bei unsauberem Abbruch!",
			"  Verwendet IFEO (Image File Execution Options) Debugger-Registry-Key",
			"  Wird automatisch bei Close-ADTSession via OnFinish-Callback aufgehoben",
			"  Benötigt Admin-Rechte! Ohne Admin wird Funktion übersprungen",
			"#>",
			"Block-ADTAppExecution -ProcessName ${1:('winword','excel','outlook')} -WindowLocation ${2|TopLeft,Top,TopRight,Left,Center,Right,BottomLeft,Bottom,BottomRight|}$0"
		],
		"description": "Blockiert die Ausführung von Anwendungen während der Installation"
	},
	"Clear-ADTModuleCallback": {
		"prefix": "clearmodulecallback",
		"body": [
			"# Native: Keine direkte Alternative - Event-basiertes Hook-System",
			"<#",
			"  Verwendung: Entfernt ALLE Callbacks von einem bestimmten Hook-Point (Bereinigung)",
			"  KRITISCH: Löscht alle registrierten Callbacks für den angegebenen Hookpoint unwiderruflich!",
			"  Unterschied zu Remove-ADTModuleCallback: Clear löscht ALLE, Remove löscht einzelne",
			"  Verwende Get-ADTModuleCallback vorher um zu sehen, was gelöscht wird",
			"#>",
			"Clear-ADTModuleCallback -Hookpoint ${1|OnInit,OnStart,PreOpen,PostOpen,PreClose,PostClose,OnFinish,OnExit|}$0"
		],
		"description": "Löscht alle Callbacks von einem bestimmten Hook-Point"
	},
	"Close-ADTInstallationProgress": {
		"prefix": "closeinstallationprogress",
		"body": [
			"# Native: Keine direkte Alternative - schließt PSADT Progress-Dialog",
			"<#",
			"  Verwendung: Schließt den Progress-Dialog der mit Show-ADTInstallationProgress geöffnet wurde",
			"  KRITISCH: Wird automatisch von Close-ADTSession aufgerufen - manueller Aufruf selten nötig!",
			"  Zeigt Balloon-Tip mit Deployment-Status (Success/Error/Warning) nach Schließen",
			"  Benötigt keine Parameter - schließt automatisch den offenen Dialog",
			"#>",
			"Close-ADTInstallationProgress$0"
		],
		"description": "Schließt den Installation-Progress-Dialog"
	},
	"Close-ADTSession": {
		"prefix": "closesession",
		"body": [
			"# Native: exit [exitcode]",
			"<#",
			"  Verwendung: Beendet die aktive ADT-Session und führt Cleanup durch (Callbacks, Logs, etc.)",
			"  KRITISCH: Bei letzter Session wird PowerShell beendet (außer mit -NoShellExit)!",
			"  Führt automatisch PreClose, OnFinish und PostClose Callbacks aus",
			"  Schließt Progress-Dialogs, hebt App-Blockierungen auf, schreibt finale Log-Einträge",
			"  ExitCode wird in $LASTEXITCODE gesetzt für nachfolgende Skripte/Aufrufer",
			"#>",
			"Close-ADTSession -ExitCode ${1:0}${2: -PassThru}$0"
		],
		"description": "Schließt die aktive ADT-Session mit optionalem Exit-Code"
	},
	"Complete-ADTFunction": {
		"prefix": "completefunction",
		"body": [
			"# Native: Keine - PSADT-internes Logging-Hilfsmittel",
			"<#",
			"  Verwendung: Beendet eine ADT-Funktion sauber mit Debug-Log und Wiederherstellung der Verbosity",
			"  KRITISCH: Sollte in jedem 'end' Block einer öffentlichen PSADT-Funktion aufgerufen werden!",
			"  Schreibt 'Function End' Log-Eintrag mit Funktionsname",
			"  Nur für Entwicklung eigener PSADT-Erweiterungen relevant - nicht für normale Deployments",
			"#>",
			"Complete-ADTFunction -Cmdlet \\$PSCmdlet$0"
		],
		"description": "Beendet eine ADT-Funktion mit Debug-Logging (für PSADT-Entwicklung)"
	},
	"Convert-ADTRegistryPath": {
		"prefix": "convertregistrypath",
		"body": [
			"# Native: Keine direkte Alternative - konvertiert Registry-Hive-Abkürzungen zu vollen Pfaden",
			"<#",
			"  Verwendung: Konvertiert Registry-Keys zu PowerShell-kompatiblem Format (z.B. HKLM → Microsoft.PowerShell.Core\\Registry::HKEY_LOCAL_MACHINE)",
			"  KRITISCH: Wandelt HKCU automatisch zu HKEY_USERS\\\\SID wenn -SID Parameter angegeben",
			"  Unterstützt Wow6432Node (32-bit Registry auf 64-bit System)",
			"  Gibt vollen PowerShell-Provider-Pfad zurück für Get-ItemProperty, Set-ItemProperty etc.",
			"#>",
			"Convert-ADTRegistryPath -Key \"${1:HKLM:\\SOFTWARE\\Microsoft}\" -SID \"${2:S-1-5-21-...}\" -Wow6432Node$0"
		],
		"description": "Konvertiert Registry-Pfad zu PowerShell-kompatiblem Format"
	},
	"Convert-ADTValueType": {
		"prefix": "convertvaluetype",
		"body": [
			"# Native: [Type]\\$variable (z.B. [byte]\\$value)",
			"<#",
			"  Verwendung: Castet Werte zu gewünschtem Typ OHNE Range-Fehler (nutzt C# statt PowerShell)",
			"  KRITISCH: Vermeidet PowerShell's Range-Exceptions bei Überlauf (z.B. 256 → Byte = 0 statt Fehler)",
			"  Unterstützte Typen: SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64",
			"  Nützlich für sichere Typ-Konvertierung bei Registry-Werten oder Binär-Operationen",
			"#>",
			"Convert-ADTValueType -Value ${1:256} -To ${2|SByte,Byte,Int16,UInt16,Int32,UInt32,Int64,UInt64|}$0"
		],
		"description": "Konvertiert Werte zu Typ ohne Range-Fehler (sichere Typ-Konvertierung)"
	},
	"Convert-ADTValuesFromRemainingArguments": {
		"prefix": "convertvaluesfromremainingarguments",
		"body": [
			"# Native: Manuelle \\$args Verarbeitung mit foreach Loop",
			"<#",
			"  Verwendung: Wandelt \\$args-Array in \\$PSBoundParameters-kompatibles Dictionary um",
			"  KRITISCH: Alles was mit '-' startet wird als neuer Parameter interpretiert!",
			"  Nützlich für Wrapper-Funktionen die unbekannte Parameter durchreichen müssen",
			"  Beispiel: -Name Test -Value 123 → @{ Name = 'Test'; Value = 123 }",
			"  Gibt System.Collections.Generic.Dictionary[String, Object] zurück",
			"#>",
			"Convert-ADTValuesFromRemainingArguments -RemainingArguments ${1:\\$args}$0"
		],
		"description": "Konvertiert \\$args-Array in Dictionary (für Parameter-Weiterleitung)"
	},
	"ConvertTo-ADTNTAccountOrSID": {
		"prefix": "converttontaccountorsid",
		"body": [
			"# Native: [System.Security.Principal.NTAccount]::new('DOMAIN\\\\User').Translate([System.Security.Principal.SecurityIdentifier])",
			"<#",
			"  Verwendung: Konvertiert zwischen NT Account Namen und SIDs (bidirektional)",
			"  KRITISCH: Verwendet ParameterSets - Get-Command ConvertTo-ADTNTAccountOrSID -Syntax zeigt alle Modi",
			"  Hauptparameter: -AccountName (→SID) | -SID (→Account) | -WellKnownSIDName (→SID/Account)",
			"  WellKnownSidTypes: [Enum]::GetNames([Security.Principal.WellKnownSidType])",
			"#>",
			"ConvertTo-ADTNTAccountOrSID -AccountName \\\"${1:CONTOSO\\\\User1}\\\"$0"
		],
		"description": "Konvertiert zwischen NT Account Namen und SIDs"
	},
	"Copy-ADTContentToCache": {
		"prefix": "copycontenttocache",
		"body": [
			"# Native: Copy-Item -Path .\\* -Destination \\$envWinDir\\Temp\\Cache -Recurse",
			"<#",
			"  Verwendung: Kopiert Toolkit-Content (Files, SupportFiles) in lokalen Cache und setzt \\$adtSession.DirFiles neu",
			"  KRITISCH: Nur für Intune! ConfigMgr hat eigenen Cache (CCMCache)",
			"  Setzt automatisch \\$adtSession.DirFiles und \\$adtSession.DirSupportFiles auf Cache-Pfad",
			"  Wichtig: Cache muss im Uninstall mit Remove-ADTFile -LiteralPath bereinigt werden!",
			"  Default CachePath: \\$envWinDir\\\\Temp\\\\PSAppDeployToolkit\\\\InstallName",
			"#>",
			"Copy-ADTContentToCache -LiteralPath \\\"${1:\\$envWinDir\\\\Temp\\\\PSAppDeployToolkit}\\\"$0"
		],
		"description": "Kopiert Toolkit-Content in lokalen Cache (für Intune)"
	},
	"Copy-ADTFile": {
		"prefix": "CopyFile",
		"body": [
			"# Native: Copy-Item -Path -Destination [-Recurse]",
			"<#",
			".DESCRIPTION",
			"  Kopiert Dateien/Ordner mit erweiterten Funktionen (Robocopy oder Native).",
			"  KRITISCH: FileCopyMode in config.psd1 definiert - Native oder Robocopy (Standard).",
			"",
			".PARAMETER Path",
			"  Quelle: Einzelne Datei, Ordner, Wildcards (*.exe), Arrays (@('file1.txt','file2.txt')).",
			"  Robocopy: * in Files erlaubt, NICHT in Ordnernamen!",
			"",
			".PATH OPTIONS",
			"  Files-Ordner: \\$adtSession.DirFiles oder \\$adtSession.DirSupportFiles.",
			"  ProgramData/ProgramFiles: \\$envProgramData, \\$envProgramFiles, \\$envProgramFilesX86.",
			"  System: \\$envWinDir, \\$envSystem32Directory, \\$envTemp.",
			"  User Profiles: \\$envUserProfile, \\$envAppData, \\$envLocalAppData.",
			"",
			".PARAMETER Destination",
			"  Ziel: Ordner oder Datei (bei einzelner Quelle).",
			"",
			".PARAMETER Recurse / Flatten / ContinueFileCopyOnError",
			"  Recurse: Kopiert Unterordner rekursiv.",
			"  Flatten: Alle Dateien in Root-Destination (ignoriert Unterordner-Struktur).",
			"  ContinueFileCopyOnError: Bei Fehler weiter (Warning statt Error).",
			"",
			".PARAMETER FileCopyMode",
			"  Native: Standard Copy-Item. Robocopy: Schneller, Multi-Threading (/MT:4), Auto-Retry.",
			"",
			".USE CASES",
			"  App Files, Config Files, DLLs, Scripts, Drivers, Certificates, Logs, Temp Files.",
			"#>",
			"Copy-ADTFile `",
			"    -Path ${1|'\\$adtSession.DirFiles\\\\*','\\$adtSession.DirSupportFiles\\\\config.xml','C:\\\\Source\\\\file.txt','C:\\\\Source\\\\Folder','\\$envTemp\\\\*.log','\\$envProgramData\\\\MyApp','\\$envProgramFiles\\\\MyApp\\\\file.dll'|} `",
			"    -Destination ${2|'C:\\\\Destination','\\$envProgramFiles\\\\MyApp','\\$envProgramData\\\\MyApp','\\$envWinDir\\\\System32','\\$envAppData\\\\MyApp','\\$envLocalAppData\\\\MyApp'|} `",
			"    ${3:-Recurse} `",
			"    ${4:-Flatten} `",
			"    ${5:-ContinueFileCopyOnError} `",
			"    -FileCopyMode ${6|Native,Robocopy|}$0"
		],
		"description": "PSADT: Copy files/folders with advanced options (Robocopy/Native)"
	},
	"Copy-ADTFileToUserProfiles": {
		"prefix": "CopyFileToUserProfiles",
		"body": [
			"# Native: ForEach User Profile → Copy-Item",
			"<#",
			"  Verwendung: Kopiert Dateien in ALLE User-Profile (C:\\\\Users\\\\<Username>\\\\...)",
			"  KRITISCH: Zwei ParameterSets - CalculatedProfiles (auto) oder SpecifiedProfiles (manuell)",
			"  BasePath-Optionen: Profile, AppData, LocalAppData, Desktop, Documents, StartMenu, Temp, OneDrive",
			"  IncludeSystemProfiles: SYSTEM, LOCAL SERVICE, NETWORK SERVICE mit einbeziehen",
			"  IncludeServiceProfiles: NT SERVICE\\\\* Accounts mit einbeziehen",
			"  ExcludeDefaultUser: Default User Profil ausschließen",
			"  Beispiel: Path config.txt + Destination AppData\\\\Roaming\\\\MyApp → C:\\\\Users\\\\*\\\\AppData\\\\Roaming\\\\MyApp\\\\config.txt",
			"#>",
			"Copy-ADTFileToUserProfiles `",
			"    -Path \\\"${1:\\$adtSession.DirSupportFiles\\\\config.txt}\\\" `",
			"    -Destination \\\"${2:AppData\\\\Roaming\\\\MyApp}\\\" `",
			"    -BasePath ${3|Profile,AppData,LocalAppData,Desktop,Documents,StartMenu,Temp,OneDrive,OneDriveCommercial|} `",
			"    -Recurse `",
			"    -Flatten `",
			"    -FileCopyMode ${4|Native,Robocopy|} `",
			"    -ExcludeNTAccount ${5:('DOMAIN\\\\User1','DOMAIN\\\\User2')} `",
			"    -IncludeSystemProfiles `",
			"    -IncludeServiceProfiles `",
			"    -ExcludeDefaultUser `",
			"    -ContinueFileCopyOnError$0"
		],
		"description": "Kopiert Dateien in alle User-Profile"
	},
	"Disable-ADTTerminalServerInstallMode": {
		"prefix": "DisableTerminalServerInstallMode",
		"body": [
			"# Native: change user /execute",
			"<#",
			"  Verwendung: Schaltet RDS/Citrix Server von Install Mode zurück zu Execute Mode (User Mode)",
			"  KRITISCH: Muss NACH Installation aufgerufen werden! Sonst bleiben User-spezifische Einstellungen deaktiviert",
			"  Install Mode: Registry-Änderungen werden in User-Template kopiert",
			"  Execute Mode: Normal User-Betrieb, jeder User bekommt eigene Registry-Änderungen",
			"  Gegenpart: Enable-ADTTerminalServerInstallMode (vor Installation)",
			"  Terminal Server prüft automatisch ob bereits im Execute Mode",
			"#>",
			"Disable-ADTTerminalServerInstallMode$0"
		],
		"description": "Schaltet Terminal Server zu User Execute Mode (nach Installation)"
	},
	"Dismount-ADTWimFile": {
		"prefix": "dismountwimfile",
		"body": [
			"# Native: Dismount-WindowsImage -Path -Discard",
			"<#",
			"  Verwendung: Unmountet WIM-Datei von Mount-Point und verwirft ALLE Änderungen",
			"  KRITISCH: -Discard = Änderungen werden NICHT gespeichert! Für Speichern andere Funktion nutzen",
			"  ParameterSets: -ImagePath (Set 1) ODER -Path (Set 2) - NICHT beide zusammen!",
			"  Entweder ImagePath angeben (alle Mount-Points dieser WIM) ODER Path (spezifischer Mount-Point)",
			"  Bei locked files: Schließt automatisch offene File-Handles und versucht erneut",
			"  WIM = Windows Imaging Format (install.wim in Windows ISO)",
			"  Verwendung: OS-Images bearbeiten, Treiber injizieren, Anpassungen vor Deployment",
			"#>",
			"Dismount-ADTWimFile -ImagePath \\\"${1:C:\\\\Images\\\\install.wim}\\\" -Path \\\"${2:C:\\\\Mount\\\\WIM}\\\"$0"
		],
		"description": "Unmountet WIM-Datei und verwirft Änderungen"
	},
	"Enable-ADTTerminalServerInstallMode": {
		"prefix": "enableterminalserverinstallmode",
		"body": [
			"# Native: change user /install",
			"<#",
			"  Verwendung: Schaltet RDS/Citrix Server zu Install Mode (VOR Installation)",
			"  KRITISCH: Muss VOR Installation aufgerufen werden! Sonst sehen nur installierende User die App",
			"  Install Mode: Registry HKCU Änderungen → HKLM Terminal Server Install (alle User)",
			"  Nach Installation: Disable-ADTTerminalServerInstallMode aufrufen (zurück zu Execute Mode)",
			"  Prüft automatisch ob bereits im Install Mode",
			"  Typischer Workflow: Enable → Installation → Disable",
			"#>",
			"Enable-ADTTerminalServerInstallMode$0"
		],
		"description": "Schaltet Terminal Server zu Install Mode (vor Installation)"
	},
	"Export-ADTEnvironmentTableToSessionState": {
		"prefix": "exportenvironmenttabletosessionstate",
		"body": [
			"# Native: Keine - PSADT-internes Variable-Export-System",
			"<#",
			"  Verwendung: Exportiert Environment-Variablen (\\$env*) in angegebenen SessionState",
			"  KRITISCH: Nur für PSADT-Entwicklung! Normale Deployments brauchen das NICHT",
			"  Get-ADTEnvironmentTable liefert alle \\$env-Variablen (envComputerName, envWinDir, etc.)",
			"  SessionState: \\$PSCmdlet.SessionState (Caller) oder \\$ExecutionContext.SessionState (aktueller Scope)",
			"  Variablen werden als ReadOnly exportiert (Schutz vor Überschreiben)",
			"  Verwendung: Eigene PSADT-Erweiterungen die Environment-Variablen benötigen",
			"#>",
			"Export-ADTEnvironmentTableToSessionState -SessionState ${1:\\$PSCmdlet.SessionState}$0"
		],
		"description": "Exportiert Environment-Variablen in SessionState (PSADT-Entwicklung)"
	},
	"Get-ADTApplication": {
		"prefix": "getapplication",
		"body": [
			"# Native: Get-ItemProperty -Path HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\*",
			"<#",
			"  Verwendung: Findet installierte Anwendungen aus Registry (32-bit und 64-bit)",
			"  KRITISCH: Durchsucht HKLM, HKCU und Wow6432Node automatisch",
			"  NameMatch: Contains (Standard), Exact, Wildcard, Regex",
			"  ApplicationType: All (Standard), MSI (nur Windows Installer), EXE (nur Setup.exe)",
			"  IncludeUpdatesAndHotfixes: Zeigt auch KB-Updates und Hotfixes (Standard: ausgeblendet)",
			"  FilterScript: Zusätzlicher Filter auf Resultate (z.B. { \\$_.Publisher -match 'Adobe' })",
			"  Gibt PSADT.Types.InstalledApplication zurück mit ProductCode, DisplayName, UninstallString, etc.",
			"#>",
			"Get-ADTApplication `",
			"    -Name ${1:'Adobe Acrobat'} `",
			"    -NameMatch ${2|Contains,Exact,Wildcard,Regex|} `",
			"    -ProductCode ${3:'{AC76BA86-7AD7-1033-7B44-AC0F074E4100}'} `",
			"    -ApplicationType ${4|All,MSI,EXE|} `",
			"    -IncludeUpdatesAndHotfixes `",
			"    -FilterScript { ${5:\\$_.Publisher -match 'Adobe'} }$0"
		],
		"description": "Findet installierte Anwendungen aus Registry"
	},
	"Get-ADTBoundParametersAndDefaultValues": {
		"prefix": "getboundparametersanddefaultvalues",
		"body": [
			"# Native: \\$PSBoundParameters + Manual Default Value Extraction",
			"<#",
			"  Verwendung: Kombiniert \\$PSBoundParameters mit Default-Werten aus Funktion (AST-basiert)",
			"  KRITISCH: Nur für PSADT-Entwicklung! Wrapper-Funktionen die alle Parameter durchreichen",
			"  Invocation: \\$MyInvocation aus der aufrufenden Funktion",
			"  ParameterSetName: Filtert Parameter nach ParameterSet",
			"  HelpMessage: Filtert Parameter nach HelpMessage-Feld",
			"  Exclude: Parameter-Namen zum Ausschließen (Array)",
			"  CommonParameters: -Verbose, -Debug, -ErrorAction etc. mit einbeziehen",
			"  Gibt Dictionary zurück (wie \\$PSBoundParameters) mit ALLEN Parametern inkl. Defaults",
			"#>",
			"Get-ADTBoundParametersAndDefaultValues `",
			"    -Invocation ${1:\\$MyInvocation} `",
			"    -ParameterSetName ${2:'MyParameterSet'} `",
			"    -HelpMessage ${3:'HelpText'} `",
			"    -Exclude ${4:('Param1','Param2')} `",
			"    -CommonParameters$0"
		],
		"description": "Kombiniert \\$PSBoundParameters mit Default-Werten (PSADT-Entwicklung)"
	},
	"Get-ADTCommandTable": {
		"prefix": "getcommandtable",
		"body": [
			"# Native: Keine - PSADT-internes Command-Lookup-System",
			"<#",
			"  Verwendung: Gibt PSADT's Safe Command Lookup Table zurück (nur öffentliche Funktionen)",
			"  KRITISCH: Nur für PSADT-Entwicklung! Eigene Module die PSADT-Commands nutzen",
			"  CommandTable = Dictionary mit CommandInfo Objekten (Get-Command Ersatz)",
			"  Enthält NUR Commands die PSADT intern nutzt (nicht alle PowerShell Commands)",
			"  ReadOnlyDictionary - kann nicht modifiziert werden",
			"  Verwendung: & \\$CommandTable.'Write-ADTLogEntry' (sichere Command-Invocation)",
			"  Private Functions sind ausgeschlossen (nur öffentliche ADT-Funktionen)",
			"#>",
			"Get-ADTCommandTable$0"
		],
		"description": "Gibt PSADT's Safe Command Lookup Table zurück (PSADT-Entwicklung)"
	},
	"Get-ADTConfig": {
		"prefix": "getconfig",
		"body": [
			"# Native: Import-PowerShellDataFile config.psd1",
			"<#",
			"  Verwendung: Gibt PSADT-Konfiguration zurück (config.psd1 Werte)",
			"  KRITISCH: Initialize-ADTModule MUSS vorher aufgerufen werden! Sonst Fehler",
			"  Gibt Hashtable mit allen Config-Werten zurück (Toolkit, UI, MSI, AppDeployment, etc.)",
			"  Config-Bereiche: Toolkit (DirFiles, CachePath), UI (Language, DialogStyle), MSI (LogPath)",
			"  Zugriff: (Get-ADTConfig).Toolkit.FileCopyMode → 'Robocopy'",
			"  Wird automatisch von Open-ADTSession aus config.psd1 geladen",
			"  Nur lesbar - zum Ändern config.psd1 bearbeiten",
			"#>",
			"Get-ADTConfig$0"
		],
		"description": "Gibt PSADT-Konfiguration zurück (aus config.psd1)"
	},
	"Get-ADTDeferHistory": {
		"prefix": "getdeferhistory",
		"body": [
			"# Native: Get-ItemProperty Registry (HKCU/HKLM DeferHistory Keys)",
			"<#",
			"  Verwendung: Gibt Defer-Historie aus Registry zurück (wann User Installation verschoben hat)",
			"  KRITISCH: Benötigt aktive ADT-Session! Open-ADTSession muss vorher aufgerufen werden",
			"  Zeigt: Anzahl Deferrals, Zeitpunkte, verbleibende Deferrals",
			"  Registry: HKCU/HKLM:\\\\SOFTWARE\\\\PSAppDeployToolkit\\\\DeferHistory\\\\AppName",
			"  Nützlich für: Prüfen ob User schon X-mal verschoben hat, MaxDefer-Limit erreicht",
			"  Gibt Defer-History-Objekt zurück mit DeferCount, DeferDeadline, DeferDates",
			"#>",
			"Get-ADTDeferHistory$0"
		],
		"description": "Gibt Defer-Historie aus Registry zurück (Installation-Verschiebungen)"
	},
	"Get-ADTEnvironmentTable": {
		"prefix": "getenvironmenttable",
		"body": [
			"# Native: Get-ChildItem Env:\\\\ + System-Infos",
			"<#",
			"  Verwendung: Gibt alle PSADT Environment-Variablen zurück (\\$env*, \\$is64Bit, etc.)",
			"  KRITISCH: Initialize-ADTModule MUSS vorher aufgerufen werden! Sonst Fehler",
			"  OrderedDictionary mit 100+ Variablen: envComputerName, envWinDir, envProgramFiles, etc.",
			"  Zusätzlich: is64Bit, isAdmin, isLTSC, envOSVersion, envOSBuild, envCulture",
			"  ReadOnly - kann nicht modifiziert werden",
			"  Verwendung: Eigene Scripts die PSADT-Variablen nutzen (ohne Session)",
			"  Export via Export-ADTEnvironmentTableToSessionState möglich",
			"#>",
			"Get-ADTEnvironmentTable$0"
		],
		"description": "Gibt alle PSADT Environment-Variablen zurück (OrderedDictionary)"
	},
	"Get-ADTEnvironmentVariable": {
		"prefix": "getenvironmentvariable",
		"body": [
			"# Native: [Environment]::GetEnvironmentVariable('Name', [EnvironmentVariableTarget]::Machine)",
			"<#",
			"  Verwendung: Liest Environment-Variable aus bestimmtem Scope (Machine, User, Process)",
			"  KRITISCH: Target bestimmt Quelle - Machine (HKLM), User (HKCU), Process (aktueller Prozess)",
			"  Ohne Target: Process-Scope (Standard \\$env:Variable)",
			"  Target User: Liest von aktiv eingeloggtem User (nicht SYSTEM!)",
			"  Unterschied zu \\$env:Path: \\$env zeigt nur Process, Get-ADTEnvironmentVariable zeigt Machine/User",
			"  Nützlich: Registry-basierte Env-Variablen lesen (JAVA_HOME, TEMP, Path)",
			"#>",
			"Get-ADTEnvironmentVariable -Variable ${1:'Path'} -Target ${2|Machine,User,Process|}$0"
		],
		"description": "Liest Environment-Variable aus bestimmtem Scope (Machine/User/Process)"
	},
	"Get-ADTExecutableInfo": {
		"prefix": "getexecutableinfo",
		"body": [
			"# Native: [System.Diagnostics.FileVersionInfo]::GetVersionInfo()",
			"<#",
			"  Verwendung: Liest detaillierte Infos aus PE-Executable (EXE/DLL) - Version, Bitness, Characteristics",
			"  KRITISCH: ParameterSets - Path (mit Wildcards) ODER LiteralPath (exakt) ODER InputObject (Pipeline)",
			"  Gibt PSADT.FileSystem.ExecutableInfo zurück: FileVersion, ProductVersion, Is64Bit, IsAssembly",
			"  Unterstützt Pipeline: Get-ChildItem *.exe | Get-ADTExecutableInfo",
			"  Zusätzliche Infos: CompanyName, FileDescription, OriginalFilename, LanguageID",
			"  Nützlich für: Version-Checks vor Installation, 32-bit/64-bit Erkennung",
			"#>",
			"Get-ADTExecutableInfo -LiteralPath \\\"${1:C:\\\\Windows\\\\System32\\\\cmd.exe}\\\" -Path \\\"${2:C:\\\\Program Files\\\\*\\\\*.exe}\\\"$0"
		],
		"description": "Liest detaillierte Infos aus PE-Executable (Version, Bitness, etc.)"
	},
	"Get-ADTFileVersion": {
		"prefix": "getfileversion",
		"body": [
			"# Native: (Get-Item file.exe).VersionInfo.FileVersion",
			"<#",
			"  Verwendung: Gibt nur Version-String zurück (einfacher als Get-ADTExecutableInfo)",
			"  KRITISCH: Validiert automatisch ob Datei existiert und VersionInfo hat - wirft Fehler wenn nicht!",
			"  FileVersion (Standard): Datei-Version (z.B. 10.0.19041.1)",
			"  ProductVersion (mit Switch): Produkt-Version (z.B. 10.0.19041.1)",
			"  Gibt String zurück (nicht Version-Object) - direkt vergleichbar",
			"  Unterschied zu Get-ADTExecutableInfo: Nur Version, keine anderen Details (CompanyName etc.)",
			"#>",
			"Get-ADTFileVersion -File \\\"${1:\\$env:ProgramFiles\\\\Adobe\\\\Reader\\\\AcroRd32.exe}\\\" -ProductVersion$0"
		],
		"description": "Gibt FileVersion oder ProductVersion als String zurück"
	},
	"Get-ADTFreeDiskSpace": {
		"prefix": "getfreediskspace",
		"body": [
			"# Native: (Get-PSDrive C).Free / 1MB",
			"<#",
			"  Verwendung: Gibt freien Speicherplatz in MB zurück (für Platz-Checks vor Installation)",
			"  KRITISCH: Validiert automatisch ob Drive existiert und Medium geladen - wirft Fehler bei USB ohne Disk!",
			"  Drive: Standard = System Drive (C:), akzeptiert DriveInfo Object",
			"  Gibt Double zurück: Freier Platz in MB (gerundet)",
			"  Nützlich: Vor großen Installationen prüfen ob genug Platz vorhanden (z.B. Office 5GB)",
			"  Beispiel: if ((Get-ADTFreeDiskSpace) -lt 5000) { Fehler: Nicht genug Platz }",
			"#>",
			"Get-ADTFreeDiskSpace -Drive ${1:'C:'}$0"
		],
		"description": "Gibt freien Speicherplatz in MB zurück (für Installations-Checks)"
	},
	"Get-ADTIniSection": {
		"prefix": "getinisection",
		"body": [
			"# Native: Komplexes Regex-Parsing oder IniFile-Modul",
			"<#",
			"  Verwendung: Liest ganze INI-Section als OrderedDictionary (Key=Value Paare)",
			"  KRITISCH: Validiert automatisch ob INI-Datei existiert und Section nicht leer!",
			"  FilePath: Pfad zur INI-Datei (z.B. notes.ini, config.ini)",
			"  Section: Section-Name in INI-Datei (z.B. [Notes], [Settings])",
			"  Gibt OrderedDictionary zurück: Alle Key-Value Paare der Section",
			"  Unterschied zu Get-ADTIniValue: GANZE Section vs. einzelner Key",
			"  Beispiel: \\$notesSettings = Get-ADTIniSection -FilePath notes.ini -Section 'Notes'",
			"  Dann: \\$notesSettings['KeyFileName'] für Zugriff auf einzelnen Key",
			"#>",
			"Get-ADTIniSection -FilePath \\\"${1:\\$env:ProgramFiles\\\\App\\\\config.ini}\\\" -Section ${2:'Settings'}$0"
		],
		"description": "Liest ganze INI-Section als OrderedDictionary"
	},
	"Get-ADTIniValue": {
		"prefix": "getinivalue",
		"body": [
			"# Native: Get-Content + Regex oder IniFile-Modul",
			"<#",
			"  Verwendung: Liest einzelnen Key-Wert aus INI-Datei",
			"  KRITISCH: Validiert automatisch FilePath, Section und Key - wirft Fehler bei leer/null!",
			"  FilePath: Pfad zur INI-Datei",
			"  Section: Section-Name (z.B. [Notes])",
			"  Key: Key-Name innerhalb der Section",
			"  Gibt String zurück: Nur der Wert des angegebenen Keys",
			"  Unterschied zu Get-ADTIniSection: Einzelner Wert vs. ganze Section",
			"  Beispiel: Get-ADTIniValue -FilePath notes.ini -Section 'Notes' -Key 'KeyFileName'",
			"#>",
			"Get-ADTIniValue -FilePath \\\"${1:\\$env:ProgramFiles\\\\App\\\\config.ini}\\\" -Section ${2:'Settings'} -Key ${3:'Version'}$0"
		],
		"description": "Liest einzelnen Key-Wert aus INI-Datei"
	},
	"Get-ADTLoggedOnUser": {
		"prefix": "getloggedonuser",
		"body": [
			"# Native: qwinsta / query user (cmd) oder Get-CimInstance Win32_LogonSession (komplex!)",
			"<#",
			"  Verwendung: Gibt detaillierte Info über ALLE eingeloggten Benutzer (lokal + RDP)",
			"  KRITISCH: Nutzt Win32 APIs - viel mehr Details als native PowerShell!",
			"  Keine Parameter - gibt automatisch alle Sessions zurück",
			"  Gibt SessionInfo-Array zurück mit 20+ Properties:",
			"    - NTAccount, SID, UserName, DomainName, SessionId",
			"    - IsCurrentSession, IsConsoleSession, IsUserSession, IsActiveUserSession",
			"    - IsRdpSession, IsLocalAdmin (prüft Administrators-Gruppe!)",
			"    - LogonTime, IdleTime, DisconnectTime",
			"    - ClientName, ClientProtocolType, ClientBuildNumber",
			"    - ConnectState (Active, Connected, Disconnected, Idle, etc.)",
			"  Nützlich: User-Context-Deployments, RDP-Checks, Admin-Prüfungen",
			"  IsActiveUserSession: Console-User oder erster aktiver RDP-User",
			"#>",
			"Get-ADTLoggedOnUser$0"
		],
		"description": "Gibt detaillierte Info über alle eingeloggten Benutzer (lokal + RDP)"
	},
	"Get-ADTModuleCallback": {
		"prefix": "getmodulecallback",
		"body": [
			"# Native: Keine - PSADT-spezifisch (Hook-System)",
			"<#",
			"  Verwendung: Gibt registrierte Callbacks für Hook-Punkt zurück (PSADT-Entwicklung)",
			"  KRITISCH: Nur für PSADT-Modul-Entwickler - nicht für normale Deployments!",
			"  Hookpoint: Hook-Punkt-Typ (ValidateSet mit 8 Optionen):",
			"    - OnInit: Vor Modul-Initialisierung",
			"    - OnStart: Vor erster Session",
			"    - PreOpen: Vor Session-Öffnung",
			"    - PostOpen: Nach Session-Öffnung",
			"    - PreClose: Vor Session-Schließung",
			"    - PostClose: Nach Session-Schließung",
			"    - OnFinish: Vor letzter Session-Schließung",
			"    - OnExit: Nach letzter Session-Schließung",
			"  Gibt CommandInfo-Array zurück: Registrierte Callback-Funktionen",
			"  Siehe auch: Add-ADTModuleCallback, Remove-ADTModuleCallback",
			"#>",
			"Get-ADTModuleCallback -Hookpoint ${1|OnInit,OnStart,PreOpen,PostOpen,PreClose,PostClose,OnFinish,OnExit|}$0"
		],
		"description": "Gibt registrierte Callbacks für Hook-Punkt zurück (PSADT-Entwicklung)"
	},
	"Get-ADTMsiExitCodeMessage": {
		"prefix": "getmsiexitcodemessage",
		"body": [
			"# Native: Keine - liest aus msimsg.dll (Windows Installer Messages)",
			"<#",
			"  Verwendung: Gibt lesbare Fehlermeldung für MSI Exit Code zurück",
			"  KRITISCH: Liest aus msimsg.dll - offizielle Microsoft-Meldungen!",
			"  MsiExitCode: Numerischer MSI Exit Code (z.B. 1618, 1603, 0)",
			"  Gibt String zurück: Lesbare Fehlermeldung aus Windows Installer",
			"  Nützlich: Nach Start-ADTMsiProcess Fehler analysieren",
			"  Häufige Codes:",
			"    - 0: Erfolg",
			"    - 1603: Fatal error during installation",
			"    - 1618: Another installation is already in progress",
			"    - 1641: Reboot initiated by installer",
			"    - 3010: Reboot required",
			"  MSDN: http://msdn.microsoft.com/en-us/library/aa368542(v=vs.85).aspx",
			"#>",
			"Get-ADTMsiExitCodeMessage -MsiExitCode ${1:1618}$0"
		],
		"description": "Gibt lesbare Fehlermeldung für MSI Exit Code zurück"
	},
	"Get-ADTMsiTableProperty": {
		"prefix": "getmsitableproperty",
		"body": [
			"# Native: Komplexes COM-Objekt WindowsInstaller.Installer (sehr komplex!)",
			"<#",
			"  Verwendung: Liest Properties aus MSI/MSP-Datenbank-Tabellen oder Summary Info",
			"  KRITISCH: 2 ParameterSets - TableInfo (default) vs. SummaryInfo - NICHT beide!",
			"  LiteralPath: Pfad zum MSI/MSP-Datei (Pflicht)",
			"  TransformPath: MST-Dateien anwenden (optional, nur für MSI)",
			"  Table: Tabellenname (default: Property für MSI, MsiPatchMetadata für MSP)",
			"  GetSummaryInformation: Switch - liest Summary Info statt Tabelle (anderer ParameterSet!)",
			"  Gibt Dictionary zurück: Key-Value Paare (TableInfo) oder MsiSummaryInfo-Object",
			"  Beispiel 1: (Get-ADTMsiTableProperty -LiteralPath app.msi).ProductCode",
			"  Beispiel 2: Get-ADTMsiTableProperty -LiteralPath app.msi -GetSummaryInformation",
			"  MSDN: https://msdn.microsoft.com/en-us/library/aa372049(v=vs.85).aspx",
			"#>",
			"Get-ADTMsiTableProperty -LiteralPath \\\"${1:\\$PSScriptRoot\\\\Files\\\\app.msi}\\\" \\`",
			"    -TransformPath \\\"${2:\\$PSScriptRoot\\\\Files\\\\custom.mst}\\\" \\`",
			"    -Table ${3:'Property'}$0"
		],
		"description": "Liest Properties aus MSI/MSP-Datenbank (ProductCode, Version etc.)"
	},
	"Get-ADTObjectProperty": {
		"prefix": "getobjectproperty",
		"body": [
			"# Native: \\$Object.PropertyName oder \\$Object.PSObject.Properties['Name'].Value",
			"<#",
			"  Verwendung: Liest Property aus beliebigem Object via Reflection (low-level)",
			"  KRITISCH: Nur für PSADT-Entwicklung oder COM-Objekte - NICHT für normale Deployments!",
			"  InputObject: Object mit Properties (z.B. COM-Objekt, Record)",
			"  PropertyName: Name der Property zum Lesen",
			"  ArgumentList: Optional - Argumente für Property (z.B. indexed properties)",
			"  Nutzt InvokeMember + Reflection.BindingFlags: Sehr low-level Property-Zugriff",
			"  Beispiel: Get-ADTObjectProperty -InputObject \\$Record -PropertyName 'StringData' -ArgumentList @(1)",
			"  Normal besser: Direkt \\$Record.StringData nutzen (wenn möglich)",
			"  Nützlich: Wenn normale Property-Zugriff nicht funktioniert (COM, private Properties)",
			"#>",
			"Get-ADTObjectProperty -InputObject ${1:\\$Object} \\`",
			"    -PropertyName ${2:'PropertyName'} \\`",
			"    -ArgumentList @(${3:1})$0"
		],
		"description": "Liest Property aus Object via Reflection (PSADT-intern)"
	},
	"Get-ADTOperatingSystemInfo": {
		"prefix": "getoperatingsysteminfo",
		"body": [
			"# Native: Get-CimInstance Win32_OperatingSystem oder [System.Environment]::OSVersion",
			"<#",
			"  Verwendung: Gibt detaillierte OS-Info zurück (Name, Version, Edition, Build etc.)",
			"  KRITISCH: Keine Parameter - cached static property! Einmal gelesen, dann cached.",
			"  Gibt OperatingSystemInfo-Object zurück mit Properties:",
			"    - Name: Windows 10, Windows 11, Windows Server 2022 etc.",
			"    - Version: Version-Object (Major.Minor.Build.Revision)",
			"    - Edition: Professional, Enterprise, Home etc.",
			"    - Architecture: x64, x86, ARM64",
			"    - IsServer: True/False",
			"    - IsWorkstation: True/False",
			"    - Build: Build-Number (z.B. 19041, 22000)",
			"  Cached: Einmal gelesen aus [PSADT.DeviceManagement.OperatingSystemInfo]::Current",
			"  Nützlich: OS-spezifische Deployment-Logik (z.B. nur Win11, nur Server)",
			"  Beispiel: if ((Get-ADTOperatingSystemInfo).IsWorkstation) { ... }",
			"#>",
			"Get-ADTOperatingSystemInfo$0"
		],
		"description": "Gibt detaillierte OS-Info zurück (Name, Version, Edition, Build)"
	},
	"Get-ADTPEFileArchitecture": {
		"prefix": "getpefilearchitecture",
		"body": [
			"# Native: Komplexes FileStream + BitConverter (PE header parsing)",
			"<#",
			"  Verwendung: Bestimmt ob PE-Datei 32-bit oder 64-bit ist (via File Header)",
			"  KRITISCH: 3 ParameterSets - Path (wildcards) vs. LiteralPath (exact) vs. InputObject (pipeline) - nur EINS!",
			"  LiteralPath: Pfad zu PE-Datei (.exe, .dll, .ocx, .drv, .sys, .scr, .efi, .cpl, .fon)",
			"  Path: Mit Wildcard-Support (z.B. *.exe)",
			"  InputObject: FileInfo-Object (Pipeline-Support)",
			"  PassThru: Switch - gibt FileInfo mit BinaryType Property zurück (statt nur Enum)",
			"  Gibt IMAGE_FILE_MACHINE Enum zurück: IMAGE_FILE_MACHINE_I386 (32-bit), IMAGE_FILE_MACHINE_AMD64 (64-bit), etc.",
			"  Liest PE Header: Offset 60 (PE Pointer), dann +4 (Machine Type)",
			"  Nützlich: Vor Installation prüfen ob 32/64-bit (z.B. nur 64-bit installieren)",
			"  Beispiel: if ((Get-ADTPEFileArchitecture -LiteralPath app.exe) -eq 'IMAGE_FILE_MACHINE_AMD64') { 64-bit }",
			"#>",
			"Get-ADTPEFileArchitecture -LiteralPath \\\"${1:\\$env:ProgramFiles\\\\App\\\\app.exe}\\\" -PassThru$0"
		],
		"description": "Bestimmt ob PE-Datei 32-bit oder 64-bit ist (File Header)"
	},
	"Get-ADTPendingReboot": {
		"prefix": "getpendingreboot",
		"body": [
			"# Native: Komplexe Registry/WMI-Checks (sehr komplex!)",
			"<#",
			"  Verwendung: Prüft ob System Pending Reboot hat (alle Quellen: CBS, WU, SCCM, Intune)",
			"  KRITISCH: Keine Parameter - checkt automatisch ALLE Reboot-Quellen!",
			"  Gibt RebootInfo-Object zurück mit Properties:",
			"    - IsSystemRebootPending: HAUPT-Property (True wenn irgendeine Quelle Reboot braucht)",
			"    - IsCBServicingRebootPending: Component Based Servicing (Vista+)",
			"    - IsWindowsUpdateRebootPending: Windows Update",
			"    - IsSCCMClientRebootPending: SCCM Client (WMI DetermineIfRebootPending)",
			"    - IsIntuneClientRebootPending: Intune Management Extension",
			"    - IsFileRenameRebootPending: Pending File Rename Operations",
			"    - PendingFileRenameOperations: Array der Dateien",
			"    - ComputerName, LastBootUpTime, ErrorMsg",
			"  Nützlich: Vor Installation Reboot-Check, nach Update Reboot erzwingen",
			"  Beispiel: if ((Get-ADTPendingReboot).IsSystemRebootPending) { Exit-ADTInvocation -ExitCode 3010 }",
			"#>",
			"Get-ADTPendingReboot$0"
		],
		"description": "Prüft ob System Pending Reboot hat (CBS, WU, SCCM, Intune)"
	},
	"Get-ADTPowerShellProcessPath": {
		"prefix": "getpowershellprocesspath",
		"body": [
			"# Native: Join-Path \\$PSHOME (powershell.exe oder pwsh.exe)",
			"<#",
			"  Verwendung: Gibt Pfad zum PowerShell Executable zurück (automatisch Windows PS vs. PS Core)",
			"  KRITISCH: Keine Parameter - erkennt automatisch aktuelle PowerShell Edition!",
			"  Gibt String zurück: Vollständiger Pfad zu powershell.exe ODER pwsh.exe",
			"  Logik: \\$PSHOME + (powershell.exe für Windows PS, pwsh.exe für PS Core)",
			"  Nützlich: Wenn du PowerShell-Prozess starten willst (z.B. Start-Process \\$psPath)",
			"  Beispiel: Start-Process -FilePath (Get-ADTPowerShellProcessPath) -ArgumentList '-NoProfile'",
			"  PSEdition = Core → pwsh.exe, Desktop → powershell.exe",
			"#>",
			"Get-ADTPowerShellProcessPath$0"
		],
		"description": "Gibt Pfad zum PowerShell Executable zurück (powershell.exe/pwsh.exe)"
	},
	"Get-ADTPresentationSettingsEnabledUsers": {
		"prefix": "getpresentationsettingsenabledusers",
		"body": [
			"# Native: Komplexer Registry-Check pro User (sehr komplex!)",
			"<#",
			"  Verwendung: Prüft ob User Presentation Mode aktiviert haben (Mobility Settings)",
			"  KRITISCH: Keine Parameter - checkt automatisch ALLE User-Profile!",
			"  Gibt UserProfile-Array zurück: Nur User mit aktivem Presentation Mode",
			"  Registry-Check: HKCU\\\\Software\\\\Microsoft\\\\MobilePC\\\\AdaptableSettings\\\\Activity",
			"  Presentation Mode: 'I am currently giving a presentation' (Mobility Center)",
			"  Nützlich: Deployment verzögern wenn User präsentiert",
			"  Gibt nichts zurück wenn kein User in Presentation Mode",
			"  Beispiel: if (Get-ADTPresentationSettingsEnabledUsers) { Defer Deployment }",
			"  Auch bekannt als: PresentationSettings.exe Feature",
			"#>",
			"Get-ADTPresentationSettingsEnabledUsers$0"
		],
		"description": "Prüft ob User Presentation Mode aktiviert haben"
	},
	"Get-ADTRegistryKey": {
		"prefix": "getregistrykey",
		"body": [
			"# Native: Get-ItemProperty (aber ohne SID/Wow6432Node Support!)",
			"<#",
			"  Verwendung: Liest Registry-Key Values (einzeln oder alle Properties)",
			"  KRITISCH: 2 ParameterSets - Path (wildcards) vs. LiteralPath - nur EINS!",
			"  LiteralPath: Registry-Pfad (HKLM:, HKCU:, HKEY_LOCAL_MACHINE etc.)",
			"  Name: Optional - spezifischer Value-Name (ohne = alle Values)",
			"  Wow6432Node: Switch - liest 32-bit Registry auf 64-bit System",
			"  SID: Optional - konvertiert HKCU zu HKU\\\\\\$SID (für andere User)",
			"  ReturnEmptyKeyIfExists: Switch - gibt leeren Key zurück statt \\$null",
			"  DoNotExpandEnvironmentNames: Switch - expandiert keine %ENVVAR% (REG_EXPAND_SZ)",
			"  Gibt zurück: String/Object (einzelner Value) oder PSCustomObject (alle Values)",
			"  Default Value: Name = '(Default)' für Registry Default-Wert",
			"  Gibt \\$null zurück: Key existiert nicht ODER keine Values (außer ReturnEmptyKeyIfExists)",
			"  Beispiel: Get-ADTRegistryKey -LiteralPath 'HKLM:\\\\SOFTWARE\\\\Adobe' -Name 'Version'",
			"#>",
			"Get-ADTRegistryKey -LiteralPath ${1:'HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion'} \\`",
			"    -Name ${2:'ProgramFilesDir'} \\`",
			"    -Wow6432Node \\`",
			"    -SID ${3:'S-1-5-21-...'}$0"
		],
		"description": "Liest Registry-Key Values (mit SID/Wow6432Node Support)"
	},
	"Get-ADTRunningProcesses": {
		"prefix": "getrunningprocesses",
		"body": [
			"# Native: Get-Process + Where-Object (aber ohne ProcessDefinition Objects!)",
			"<#",
			"  Verwendung: Prüft ob Prozesse aus ProcessDefinition-Array laufen",
			"  KRITISCH: Benötigt ProcessDefinition Objects - NICHT einfache Strings!",
			"  ProcessObjects: Array von ProcessDefinition Objects (z.B. von Close-ADTApplication)",
			"  Gibt RunningProcess-Array zurück: Nur laufende Prozesse aus der Liste",
			"  Gibt \\$null zurück: Wenn keine Prozesse laufen",
			"  ProcessDefinition: Object mit Name, Description, ProductName, Company etc.",
			"  Nützlich: Nach Close-ADTApplication prüfen ob Prozesse noch laufen",
			"  Beispiel: \\$running = Get-ADTRunningProcesses -ProcessObjects \\$processDefinitions",
			"  Unterschied zu Get-Process: Nutzt ProcessDefinition Objects (komplexer)",
			"#>",
			"Get-ADTRunningProcesses -ProcessObjects ${1:\\$processDefinitions}$0"
		],
		"description": "Prüft ob Prozesse aus ProcessDefinition-Array laufen"
	},
	"Get-ADTServiceStartMode": {
		"prefix": "getservicestartmode",
		"body": [
			"# Native: (Get-Service).StartType (aber erkennt kein Delayed Start!)",
			"<#",
			"  Verwendung: Gibt Service Startup Mode zurück (mit Delayed Start Detection!)",
			"  KRITISCH: Benötigt ServiceController Object - NICHT Service-Name String!",
			"  Service: ServiceController Object (z.B. Get-Service -Name 'wuauserv')",
			"  Gibt String zurück: Startup Mode (Manual, Automatic, Disabled, Automatic (Delayed Start))",
			"  Besonderheit: Erkennt 'Automatic (Delayed Start)' via Registry DelayedAutoStart!",
			"  Native .StartType zeigt nur 'Automatic' - kein Delayed-Flag!",
			"  Registry: HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\ServiceName\\\\DelayedAutoStart",
			"  Nützlich: Vor/Nach Service-Änderungen Startup Mode prüfen",
			"  Beispiel: Get-ADTServiceStartMode -Service (Get-Service -Name 'wuauserv')",
			"#>",
			"Get-ADTServiceStartMode -Service (Get-Service -Name ${1:'wuauserv'})$0"
		],
		"description": "Gibt Service Startup Mode zurück (mit Delayed Start Detection)"
	},
	"Get-ADTSession": {
		"prefix": "getsession",
		"body": [
			"# Native: $Script:ADT.Sessions[-1] (direkter Zugriff auf Session-Array)",
			"<#",
			"  Verwendung: Gibt die zuletzt aktive ADT-Session zurück (nach Close-ADTSession)",
			"  KRITISCH: Open-ADTSession MUSS vorher aufgerufen worden sein - sonst Fehler!",
			"  Keine Parameter - gibt automatisch letzte Session aus \\$Script:ADT.Sessions[-1]",
			"  Gibt ADTSession Object zurück mit: ExitCode, AppName, DeploymentType, InstallName etc.",
			"  Nützlich: Exit Code nach Close-ADTSession abrufen für Logging/Reporting",
			"  Wirft Fehler: Wenn keine Session existiert (Initialize-ADTModule nicht aufgerufen)",
			"  Beispiel: \\$lastSession = Get-ADTSession; Write-Host \\$lastSession.ExitCode",
			"#>",
			"Get-ADTSession$0"
		],
		"description": "Gibt die zuletzt aktive ADT-Session zurück (Exit Code etc.)"
	},
	"Get-ADTShortcut": {
		"prefix": "getshortcut",
		"body": [
			"# Native: $WshShell = New-Object -ComObject WScript.Shell; $Shortcut = $WshShell.CreateShortcut(...)",
			"<#",
			"  Verwendung: Liest Informationen aus .lnk oder .url Shortcut-Dateien",
			"  KRITISCH: Validiert automatisch .lnk/.url Extension - andere Dateien werfen Fehler!",
			"  LiteralPath: Pfad zur Shortcut-Datei (.lnk für Windows Shortcuts, .url für Internet Shortcuts)",
			"  Gibt zurück: PSADT.Types.ShortcutLnk ODER PSADT.Types.ShortcutUrl Object",
			"  .lnk Properties: TargetPath, Arguments, Description, WorkingDirectory, WindowStyle, Hotkey, IconLocation, IconIndex, RunAsAdmin",
			"  .url Properties: Nur TargetPath, IconLocation, IconIndex (weniger als .lnk!)",
			"  Nützlich: Shortcuts analysieren, TargetPath prüfen, vor Shortcut-Erstellung vergleichen",
			"  Beispiel: (Get-ADTShortcut -LiteralPath 'C:\\\\Users\\\\Public\\\\Desktop\\\\App.lnk').TargetPath",
			"#>",
			"Get-ADTShortcut -LiteralPath \\\"${1:C:\\\\Users\\\\Public\\\\Desktop\\\\App.lnk}\\\"$0"
		],
		"description": "Liest Informationen aus .lnk oder .url Shortcut-Dateien"
	},
	"Get-ADTStringTable": {
		"prefix": "getstringtable",
		"body": [
			"# Native: Import-PowerShellDataFile PSAppDeployToolkit\\\\Strings\\\\de\\\\strings.psd1",
			"<#",
			"  Verwendung: Gibt PSADT's UI-Texte zurück (BalloonTip, Progress, CloseApps etc.)",
			"  KRITISCH: Normal deployment'larda NICHT NÖTIG! PSADT wählt automatisch richtige Texte",
			"  Initialize-ADTModule MUSS vorher aufgerufen werden - sonst Fehler!",
			"  Keine Parameter - gibt automatisch \\$Script:ADT.Strings zurück",
			"  Gibt Hashtable zurück: Lokalisierte Strings für aktuelle Kultur (de, en, fr etc.)",
			"  Struktur: Jeder String hat 3 Versionen - Install, Repair, Uninstall",
			"  Kategorien: BalloonTip, BlockExecutionText, CloseAppsPrompt, DiskSpaceText, InstallationPrompt, ProgressPrompt, RestartPrompt",
			"  Beispiel: \\$strings = Get-ADTStringTable; \\$strings.BalloonTip.Start.Install → 'Installation wurde gestartet.'",
			"  Verwendung: Nur für custom Dialogs wo du PSADT-Stil beibehalten willst",
			"  Show-ADTInstallationWelcome nutzt diese Strings automatisch - du musst sie NICHT abrufen!",
			"#>",
			"Get-ADTStringTable$0"
		],
		"description": "Gibt PSADT's UI-Texte zurück (BalloonTip, Progress etc.) - Normal NICHT nötig!"
	},
	"Get-ADTUserNotificationState": {
		"prefix": "getusernotificationstate",
		"body": [
			"# Native: Komplexe Win32 API SHQueryUserNotificationState (sehr komplex!)",
			"<#",
			"  Verwendung: Prüft Notification State des eingeloggten Users (Präsentation, Vollbild, etc.)",
			"  KRITISCH: Gibt nichts zurück wenn kein User eingeloggt ist - prüfe auf \\$null!",
			"  Keine Parameter - prüft automatisch aktiven User",
			"  Gibt QUERY_USER_NOTIFICATION_STATE Enum zurück:",
			"    - QUNS_NOT_PRESENT (1): User nicht anwesend",
			"    - QUNS_BUSY (2): User beschäftigt",
			"    - QUNS_RUNNING_D3D_FULL_SCREEN (3): DirectX Vollbild-App läuft",
			"    - QUNS_PRESENTATION_MODE (4): Presentation Mode aktiv",
			"    - QUNS_ACCEPTS_NOTIFICATIONS (5): User akzeptiert Notifications (normal)",
			"    - QUNS_QUIET_TIME (6): Ruhezeit (Focus Assist)",
			"    - QUNS_APP (7): App im Vollbild",
			"  Nützlich: Deployment verzögern wenn User in Presentation Mode oder Vollbild-App",
			"  Beispiel: if ((Get-ADTUserNotificationState) -eq 'QUNS_PRESENTATION_MODE') { Defer }",
			"#>",
			"Get-ADTUserNotificationState$0"
		],
		"description": "Prüft Notification State des Users (Präsentation, Vollbild, etc.)"
	},
	"Get-ADTUserProfiles": {
		"prefix": "getuserprofiles",
		"body": [
			"# Native: Get-CimInstance Win32_UserProfile (aber ohne viele Details!)",
			"<#",
			"  Verwendung: Gibt ALLE User-Profile zurück (NTAccount, SID, ProfilePath)",
			"  KRITISCH: 2 ParameterSets - All (mit Filtern) vs. FilterScript (custom ScriptBlock)",
			"  FilterScript: ScriptBlock zum Filtern (z.B. { \\$_.NTAccount -match 'CONTOSO' })",
			"  ExcludeNTAccount: Array von DOMAIN\\\\Username zum Ausschließen",
			"  IncludeSystemProfiles: SYSTEM, LOCAL SERVICE, NETWORK SERVICE mit einbeziehen (default: excluded)",
			"  IncludeServiceProfiles: NT SERVICE\\\\* Accounts mit einbeziehen (default: excluded)",
			"  IncludeIISAppPoolProfiles: IIS AppPool Profiles mit einbeziehen (default: excluded, parsen schlecht)",
			"  ExcludeDefaultUser: Default User Profil ausschließen (default: included!)",
			"  LoadProfilePaths: Zusätzliche Pfade laden (AppData, Desktop, Documents, StartMenu, Temp, OneDrive)",
			"  Gibt zurück: PSADT.Types.UserProfile mit NTAccount, SID, ProfilePath (+ mehr mit LoadProfilePaths)",
			"  Nützlich: User-spezifische Operationen (Dateien kopieren, Registry ändern, Profile analysieren)",
			"  Beispiel: Get-ADTUserProfiles | Select-Object -ExpandProperty ProfilePath",
			"  Alternative: Copy-ADTFileToUserProfiles für Datei-Operationen (einfacher!)",
			"#>",
			"Get-ADTUserProfiles \\`",
			"    -ExcludeNTAccount ${1:('CONTOSO\\\\Robot','CONTOSO\\\\Admin')} \\`",
			"    -IncludeSystemProfiles \\`",
			"    -ExcludeDefaultUser \\`",
			"    -LoadProfilePaths$0"
		],
		"description": "Gibt alle User-Profile zurück (NTAccount, SID, ProfilePath)"
	},
	"Get-ADTWindowTitle": {
		"prefix": "getwindowtitle",
		"body": [
			"# Native: Get-Process | Where-Object MainWindowTitle (aber ohne Window Details!)",
			"<#",
			"  Verwendung: Sucht offene Fenster nach Title, Handle oder Prozessname",
			"  KRITISCH: Funktioniert NICHT in SYSTEM context! Nur als User oder mit psexec -s -i",
			"  WindowTitle: Regex für Window-Titel (z.B. 'Microsoft Word')",
			"  WindowHandle: IntPtr Array von Window-Handles",
			"  ParentProcess: Prozessname Array (z.B. 'WINWORD', 'chrome')",
			"  ALLE Parameter optional - OHNE Parameter = ALLE offenen Fenster!",
			"  Gibt zurück: PSADT.WindowManagement.WindowInfo mit Properties:",
			"    - WindowTitle: Fenster-Titel",
			"    - WindowHandle: IntPtr Handle",
			"    - ParentProcess: Prozessname",
			"    - ParentProcessMainWindowHandle: Main Window Handle vom Parent",
			"    - ParentProcessId: Process ID",
			"  Nützlich: Prüfen ob bestimmte App-Fenster offen sind, Window-Info für Automation",
			"  Beispiel 1: Get-ADTWindowTitle (alle Fenster)",
			"  Beispiel 2: Get-ADTWindowTitle -WindowTitle 'Microsoft Word'",
			"  Beispiel 3: Get-ADTWindowTitle -ParentProcess 'WINWORD'",
			"#>",
			"Get-ADTWindowTitle${1: -WindowTitle '${2:Microsoft Word}'}$0"
		],
		"description": "Sucht offene Fenster nach Title/Handle/Process (NICHT in SYSTEM!)"
	},
	"Initialize-ADTFunction": {
		"prefix": "initializefunction",
		"body": [
			"# Native: Keine - PSADT-internes Function-Initialization-System",
			"<#",
			"  Verwendung: Initialisiert ADT Function Environment (Debug-Logging, ErrorActionPreference)",
			"  KRITISCH: Nur für PSADT-Entwicklung - NICHT für normale Deployments!",
			"  Muss im 'begin' Block jeder öffentlichen PSADT-Funktion aufgerufen werden",
			"  Paar mit Complete-ADTFunction (begin → Initialize, end → Complete)",
			"  Funktionen:",
			"    - Schreibt 'Function Start' Debug-Log mit Function-Name",
			"    - Loggt alle Bound Parameters (Name, Value, Type) als Tabelle",
			"    - Setzt ErrorActionPreference = Stop (überschreibt Caller)",
			"    - Speichert Original ErrorAction in \\$OriginalErrorAction Variable",
			"  SessionState: Optional - für Cross-SessionState Variable-Export",
			"  Nur relevant bei eigenen PSADT-Erweiterungen (custom Functions)",
			"#>",
			"Initialize-ADTFunction -Cmdlet ${1:\\$PSCmdlet}${2: -SessionState \\$PSCmdlet.SessionState}$0"
		],
		"description": "Initialisiert ADT Function Environment (PSADT-Entwicklung)"
	},
	"Initialize-ADTModule": {
		"prefix": "initializemodule",
		"body": [
			"# Native: Keine - PSADT-spezifische Module-Initialisierung",
			"<#",
			"  Verwendung: Initialisiert PSADT Module (lädt Config, Strings, Environment)",
			"  KRITISCH: Normal deployments brauchen das NICHT - wird automatisch aufgerufen!",
			"  Kann NICHT während aktiver ADTSession aufgerufen werden (wirft Fehler)",
			"  Funktionen:",
			"    - Lädt config.psd1 → \\$Script:ADT.Config",
			"    - Lädt strings.psd1 → \\$Script:ADT.Strings (Sprache auto-detected)",
			"    - Erstellt Environment Table → \\$Script:ADT.Environment (alle \\$env* Variablen)",
			"    - Führt OnInit Callbacks aus",
			"    - Setzt \\$Script:ADT.Initialized = \\$true",
			"  ScriptDirectory: Override für config/strings Pfad (Array möglich!)",
			"  AdditionalEnvironmentVariables: Zusätzliche Variables in Environment Table",
			"  Nur relevant: Modul-Reinitialisierung nach Änderungen oder Tests",
			"#>",
			"Initialize-ADTModule${1: -ScriptDirectory \\\"${2:\\$PSScriptRoot}\\\"}${3: -AdditionalEnvironmentVariables @{ ${4:Key} = '${5:Value}' \\}}$0"
		],
		"description": "Initialisiert PSADT Module (Config, Strings, Environment) - Normal NICHT nötig!"
	},
	"Install-ADTMSUpdates": {
		"prefix": "installmsupdates",
		"body": [
			"# Native: Manuell wusa.exe + msiexec für jedes Update (sehr komplex!)",
			"<#",
			"  Verwendung: Installiert alle Microsoft Updates (.exe, .msu, .msp) in einem Ordner",
			"  KRITISCH: DEPRECATED! Wird in PSADT 4.2.0 entfernt - NICHT mehr verwenden!",
			"  Durchsucht Directory rekursiv nach Updates (.exe, .msu, .msp)",
			"  Prüft automatisch ob KB bereits installiert (Test-ADTMSUpdates)",
			"  Update-Typen:",
			"    - .exe: Office Updates → /quiet /norestart",
			"    - .msu: Windows Updates → wusa.exe /quiet /norestart",
			"    - .msp: MSI Patches → Start-ADTMsiProcess -Action Patch",
			"  Redist-Handling: Erkennt VC++ Redistributables (vcredist) und installiert mit /q",
			"  KB-Erkennung: Regex Pattern 'kb\\\\d{6,8}' (z.B. KB4589210)",
			"  IgnoreExitCodes '*': Alle Exit Codes werden akzeptiert (keine Fehler!)",
			"  Alternative: Install-ADTSCCMSoftwareUpdates (nur für SCCM)",
			"#>",
			"Install-ADTMSUpdates -Directory \\\"${1:\\$adtSession.DirFiles\\\\MSUpdates}\\\"$0"
		],
		"description": "Installiert Microsoft Updates (.exe, .msu, .msp) - DEPRECATED 4.2.0!"
	},
	"Install-ADTSCCMSoftwareUpdates": {
		"prefix": "installsccmsoftwareupdates",
		"body": [
			"# Native: Komplexes WMI/CIM mit ROOT\\\\CCM\\\\ClientSDK (sehr komplex!)",
			"<#",
			"  Verwendung: Scannt und installiert pending SCCM Software Updates",
			"  KRITISCH: Nur SCCM 2012 Client oder höher! Kann MEHRERE MINUTEN dauern!",
			"  Workflow:",
			"    1. Invoke-ADTSCCMTask -ScheduleID SoftwareUpdatesScan (triggert SCCM scan)",
			"    2. Wartet SoftwareUpdatesScanWaitInSeconds (default 180s = 3 Min) für Scan",
			"    3. Get-CimInstance ROOT\\\\CCM\\\\ClientSDK CCM_SoftwareUpdate (ComplianceState = 0 → Missing)",
			"    4. Invoke-CimMethod CCM_SoftwareUpdatesManager.InstallUpdates (installiert Updates)",
			"    5. Loop: 60s Intervall, prüft EvaluationState 6/7 bis Timeout (default 45 Min)",
			"  ComplianceState:",
			"    - 0: Non-Compliant (Missing Update - muss installiert werden)",
			"    - 1: Compliant (Update bereits installiert)",
			"  EvaluationState:",
			"    - 6: Installing (Update wird gerade installiert)",
			"    - 7: Waiting for reboot (Update installiert, Reboot pending)",
			"  Parameter:",
			"    - SoftwareUpdatesScanWaitInSeconds: Default 180s (wie lange Scan-Finish warten)",
			"    - WaitForPendingUpdatesTimeout: Default 45 Min TimeSpan (wie lange Installation warten)",
			"  WMI Namespace: ROOT\\\\CCM\\\\ClientSDK (SCCM Client SDK)",
			"  WARNUNG: Thread.Sleep blockiert - keine User-Interaktion während Scan!",
			"  Return: Nichts - nur Logs. Prüfe Get-ADTPendingReboot nach Ausführung",
			"#>",
			"Install-ADTSCCMSoftwareUpdates `",
			"    -SoftwareUpdatesScanWaitInSeconds ${1:180} `",
			"    -WaitForPendingUpdatesTimeout ([TimeSpan]::FromMinutes(${2:45}))$0"
		],
		"description": "Scannt und installiert SCCM Software Updates (nur SCCM 2012+!)"
	},
	"Invoke-ADTAllUsersRegistryAction": {
		"prefix": "invokeallusersregistryaction",
		"body": [
			"# Native: ForEach User → reg.exe LOAD NTUSER.DAT + Registry-Änderungen + reg.exe UNLOAD",
			"<#",
			"  Verwendung: Setzt HKCU Registry-Einstellungen für ALLE User (aktuelle + zukünftige)",
			"  KRITISCH: Lädt NTUSER.DAT Hives manuell - funktioniert auch unter SYSTEM Account!",
			"  Alternative zu ActiveSetup: Änderungen sofort aktiv (KEIN Logoff/Logon nötig)",
			"  ScriptBlock erhält \\$_ Variable mit UserProfile Object (\\$_.SID, \\$_.NTAccount, etc.)",
			"  Workflow:",
			"    1. Get-ADTUserProfiles → alle User-Profile",
			"    2. Für jeden User: Test ob HKEY_USERS\\\\SID bereits geladen",
			"    3. Falls NICHT geladen → reg.exe LOAD 'HKU\\\\SID' 'C:\\\\Users\\\\User\\\\NTUSER.DAT'",
			"    4. ScriptBlock ausführen (Registry-Änderungen mit -SID \\$_.SID)",
			"    5. reg.exe UNLOAD 'HKU\\\\SID' (nur wenn wir geladen haben)",
			"  UserProfiles: Optional - eigene User-Liste (z.B. Get-ADTUserProfiles -ExcludeDefaultUser)",
			"  SkipUnloadedProfiles: Nur bereits eingeloggte User bearbeiten (keine NTUSER.DAT loads)",
			"  Default User: Wird automatisch modifiziert (neue User bekommen Settings)",
			"  WICHTIG: Nutze Set-ADTRegistryKey mit -SID \\$_.SID im ScriptBlock!",
			"  Beispiel: Set-ADTRegistryKey -SID \\$_.SID -Key 'HKCU\\\\Software\\\\App' -Name 'Setting' -Value 1",
			"  Garbage Collection: GC.Collect + WaitForPendingFinalizers vor UNLOAD (locks vermeiden)",
			"#>",
			"Invoke-ADTAllUsersRegistryAction ${1:-UserProfiles (Get-ADTUserProfiles -ExcludeDefaultUser) }-ScriptBlock {",
			"    Set-ADTRegistryKey -SID \\$_.SID -Key 'HKCU\\\\Software\\\\${2:Microsoft\\\\Office\\\\14.0\\\\Common}' -Name '${3:qmenable}' -Value ${4:0} -Type ${5|DWord,String,QWord,Binary,MultiString,ExpandString|}",
			"    ${Set-ADTRegistryKey -SID \\$_.SID -Key 'HKCU\\\\Software\\\\${6:Microsoft\\\\Office\\\\14.0\\\\Common}' -Name 'updatereliabilitydata' -Value 1 -Type DWord}",
			"}$0"
		],
		"description": "Setzt HKCU Registry für ALLE User (lädt NTUSER.DAT, Alternative zu ActiveSetup)"
	},
	"invokecommandwithretries": {
		"prefix": "invokecommandwithretries",
		"body": [
			"# Native Alternative: while-Schleife mit try-catch, Start-Sleep, Zähler-Variable",
			"<#",
			"  VERWENDUNG: Retry-Mechanismus für beliebige Cmdlets/Funktionen (Drop-in Replacement)",
			"  - Transiente Fehler: Netzwerk-Timeouts, SMB-Verbindungsabbrüche, Web-Requests",
			"  - Parameter-Weiterleitung: Alle Parameter des Original-Commands werden durchgereicht",
			"  - Zwei Exit-Bedingungen: -Retries erschöpft ODER -MaximumElapsedTime überschritten",
			"  - Default: 3 Retries mit 5 Sekunden Sleep zwischen Versuchen",
			"  - Kein aktiver ADT Session erforderlich!",
			"",
			"  WORKFLOW:",
			"  1. Command-Objekt auflösen (Get-Command oder CommandTable-Lookup)",
			"  2. Parameter konvertieren (ValueFromRemainingArguments → Splatting-Dictionary)",
			"  3. ErrorAction = Stop erzwingen (wenn Command unterstützt)",
			"  4. Stopwatch starten (bei -MaximumElapsedTime)",
			"  5. While-Schleife: Invoke Command → Bei Fehler: Log + Sleep + Retry",
			"  6. Exit wenn: Retries erschöpft ODER MaximumElapsedTime überschritten",
			"",
			"  KRITISCH:",
			"  - SleepSeconds: DEPRECATED (wird in PSADT 4.2.0 entfernt) → Nutze -SleepDuration!",
			"  - MaximumElapsedTime: Wenn gesetzt ohne -Retries → Endlos-Retry bis Zeitlimit",
			"  - MaximumElapsedTime: Wenn mit -Retries kombiniert → Beide Bedingungen prüfen (OR)",
			"  - ValueFromRemainingArguments: Parameter direkt nach Command-Name angeben (kein Splat)",
			"  - ErrorAction: Wird automatisch auf Stop gesetzt (sonst funktioniert Retry-Logik nicht)",
			"  - Thread.Sleep: Blockiert PowerShell während Sleep (keine User-Interaktion möglich)",
			"  - Command-Typen: CommandInfo-Objekt, String-Name oder CommandTable-Entry",
			"  Beispiel SMB Share: Copy-ADTFile, Get-FileHash von instabilen Netzwerk-Shares",
			"  Beispiel Web Request: Invoke-WebRequest mit Retry bei Timeout/Connection-Reset",
			"#>",
			"Invoke-ADTCommandWithRetries ${1:-Command} ${2:Get-FileHash} ${3:-Path '\\\\\\\\${4:MyShare}\\\\${5:MyFile}'} ${6:-Retries ${7:5}} ${8:-SleepDuration (New-TimeSpan -Seconds ${9:5})} ${10:-MaximumElapsedTime (New-TimeSpan -Minutes ${11:5})}$0"
		],
		"description": "Retry-Mechanismus für Cmdlets/Funktionen mit transienten Fehlern (Drop-in Replacement)"
	},
	"invokefunctionerrorhandler": {
		"prefix": "invokefunctionerrorhandler",
		"body": [
			"# Native Alternative: try-catch mit Write-Error/throw, $PSCmdlet.ThrowTerminatingError()",
			"<#",
			"  VERWENDUNG: Zentrale Error-Handler für ADT-Funktionen (NUR für PSADT-Modul-Entwickler!)",
			"  - Catch-Blöcke: Standardisierte Fehlerbehandlung in allen ADT-Funktionen",
			"  - Logging: Schreibt Fehler in ADTSession-Log mit Severity 3",
			"  - ErrorAction-Recovery: Stellt echten ErrorAction-Wert vom Caller wieder her",
			"  - Error-Resolution: Erweiterte ErrorRecord-Property-Extraktion für detaillierte Logs",
			"  - Kein aktiver ADT Session erforderlich!",
			"",
			"  WORKFLOW:",
			"  1. OriginalErrorAction vom Caller abrufen (aus SessionState-Variable)",
			"  2. ErrorActionPreference wiederherstellen (überschreibt interne Werte)",
			"  3. LogMessage generieren: Custom message ODER ErrorRecord.Exception.Message",
			"  4. Error-Resolution: Resolve-ADTErrorRecord für detaillierte Property-Ausgabe",
			"  5. Write-ADTLogEntry mit Severity 3 (Error) + Source = Cmdlet-Name",
			"  6. ErrorAction-basierte Behandlung:",
			"     - Stop → ThrowTerminatingError()",
			"     - Continue/Inquire → WriteError() (non-terminating)",
			"     - SilentlyContinue/Ignore → Nur loggen, kein Output",
			"",
			"  KRITISCH:",
			"  - NUR für PSADT-Modul-Entwickler! Normale Nutzer verwenden try-catch direkt",
			"  - Cmdlet-Parameter: Immer \\$PSCmdlet übergeben (für ThrowTerminatingError)",
			"  - SessionState: Immer \\$ExecutionContext.SessionState (für Variable-Zugriff)",
			"  - ErrorRecord: \\$_ aus catch-Block",
			"  - Silent-Modus: Kein Logging, nur ErrorRecord-Handling (nützlich für interne Fehler)",
			"  - DisableErrorResolving: Verhindert Resolve-ADTErrorRecord-Anhang an LogMessage",
			"  - ResolveErrorProperties: Nur spezifische Properties loggen (Wildcards erlaubt)",
			"  - CategoryInfo.Activity: Wird automatisch auf Cmdlet-Name überschrieben (statt Write-Error)",
			"  Verwendung in Funktionen: Immer in catch-Block am Ende before function-end",
			"  Beispiel: catch { Invoke-ADTFunctionErrorHandler -Cmdlet \\$PSCmdlet -SessionState \\$ExecutionContext.SessionState -ErrorRecord \\$_ }",
			"#>",
			"Invoke-ADTFunctionErrorHandler -Cmdlet \\$PSCmdlet -SessionState \\$ExecutionContext.SessionState -ErrorRecord \\$_ ${1:-LogMessage '${2:An error occurred}'} ${3:-Silent} ${4:-DisableErrorResolving}$0"
		],
		"description": "Zentrale Error-Handler für ADT-Funktionen (Logging + ErrorAction-Recovery, nur für Modul-Entwickler)"
	},
	"invokeobjectmethod": {
		"prefix": "invokeobjectmethod",
		"body": [
			"# Native Alternative: \\$Object.MethodName(args) oder [Type]::InvokeMember()",
			"<#",
			"  VERWENDUNG: Method auf COM/NET-Objekten aufrufen (mit/ohne Named Parameters)",
			"  - COM-Objekte: Shell.Application, WScript.Shell, Scripting.FileSystemObject, etc.",
			"  - .NET-Objekte: Beliebige .NET-Typen mit InvokeMember-Reflection",
			"  - Zwei Modi: Named Parameters (Hashtable) oder Positional (Array)",
			"  - Reflection-basiert: GetType().InvokeMember() mit BindingFlags",
			"  - Kein aktiver ADT Session erforderlich!",
			"",
			"  WORKFLOW:",
			"  1. InputObject empfangen (COM oder .NET Objekt)",
			"  2. MethodName als String",
			"  3. Parameter-Set prüfen: Named (Hashtable) oder Positional (Array)",
			"  4. InvokeMember aufrufen:",
			"     - Named: Keys als Parameternamen, Values als Werte",
			"     - Positional: Array-Elemente als Argumente in Reihenfolge",
			"  5. Rückgabewert des Methods zurückgeben",
			"",
			"  KRITISCH:",
			"  - Named vs Positional: NICHT kombinierbar (Parameter Sets!)",
			"  - COM-Objekte: New-Object -ComObject vor Invoke-ADTObjectMethod",
			"  - Named-Modus: Hashtable mit @{ParameterName='Value'}",
			"  - Positional-Modus: Array mit Werten in korrekter Reihenfolge",
			"  - InvokeMember: Reflection-Overhead (langsamer als direkte Calls)",
			"  - Return-Wert: Method-Rückgabe direkt durchgereicht (kann \\$null sein)",
			"  Beispiel COM: Shell.Application → MinimizeAll() (alle Fenster minimieren)",
			"  Beispiel COM Named: Shell.Application → Explore(@{vDir='C:\\\\Windows'})",
			"  Beispiel .NET: [System.IO.File]::ReadAllText() via InvokeMember",
			"#>",
			"${1|# Named Parameters (Hashtable),# Positional Parameters (Array)|}",
			"\\$${2:ShellApp} = New-Object -ComObject '${3:Shell.Application}'",
			"${4|Invoke-ADTObjectMethod -InputObject,\\$null =|} \\$${2:ShellApp} ${5|-MethodName '${6:Explore}' -Parameter @{${7:'vDir'}='${8:C:\\\\Windows}'},-MethodName '${9:MinimizeAll}'|}$0"
		],
		"description": "Ruft Method auf COM/NET-Objekten auf (Named/Positional Parameters via Reflection)"
	},
	"invokeregsvr32": {
		"prefix": "invokeregsvr32",
		"body": [
			"# Native Alternative: regsvr32.exe /s \"file.dll\" oder regsvr32.exe /s /u \"file.dll\"",
			"<#",
			"  VERWENDUNG: DLL-Dateien registrieren/deregistrieren (COM/ActiveX Components)",
			"  - COM-DLLs: ActiveX Controls, Shell Extensions, Context Menu Handlers",
			"  - Bitness-Detection: Automatische Erkennung 32-bit/64-bit DLL",
			"  - RegSvr32-Path: Wählt korrekte regsvr32.exe (System32, SysWOW64, sysnative)",
			"  - Silent Mode: /s Flag (keine Dialoge)",
			"  - Kein aktiver ADT Session erforderlich!",
			"",
			"  WORKFLOW:",
			"  1. DLL-Pfad validieren (existiert + .dll Extension)",
			"  2. DLL Bitness ermitteln (Get-ADTPEFileArchitecture)",
			"  3. Korrekten regsvr32.exe Pfad bestimmen:",
			"     - 64-bit OS + 64-bit DLL → System32\\\\regsvr32.exe (oder sysnative bei WOW64)",
			"     - 64-bit OS + 32-bit DLL → SysWOW64\\\\regsvr32.exe",
			"     - 32-bit OS + 32-bit DLL → System32\\\\regsvr32.exe",
			"  4. Action-Parameter generieren:",
			"     - Register: /s \\\"FilePath\\\"",
			"     - Unregister: /s /u \\\"FilePath\\\"",
			"  5. Start-ADTProcess mit regsvr32.exe + Parameter",
			"  6. Exit-Code prüfen (0 = Success)",
			"",
			"  KRITISCH:",
			"  - FilePath: Muss existieren + .dll Extension (ValidateScript prüft)",
			"  - Action: Nur 'Register' oder 'Unregister' (ValidateSet)",
			"  - Bitness-Matching: 64-bit DLL auf 32-bit OS → FEHLER!",
			"  - WOW64-Redirect: PowerShell 32-bit auf 64-bit OS → sysnative statt System32",
			"  - Exit-Codes: 0 = Success, 60002 = Start-ADTProcess Fehler, andere = regsvr32 Fehler",
			"  - Silent-Mode: Nutzer sieht keine Error-Dialoge (nur Log)",
			"  Verwendung: Setup-DLLs für COM-Objekte, Browser-Plugins, Shell-Erweiterungen",
			"  Beispiel Register: ActiveX Control für Legacy Web App",
			"  Beispiel Unregister: Alte DLL vor Update entfernen",
			"#>",
			"Invoke-ADTRegSvr32 -FilePath '${1:C:\\\\Test\\\\DcTLSFileToDMSComp.dll}' -Action ${2|Register,Unregister|}$0"
		],
		"description": "Registriert/Deregistriert DLL-Dateien (regsvr32.exe mit Bitness-Detection)"
	},
	"invokesccmtask": {
		"prefix": "invokesccmtask",
		"body": [
			"# Native Alternative: Invoke-CimMethod -Namespace ROOT\\\\CCM -ClassName SMS_Client -MethodName TriggerSchedule",
			"<#",
			"  VERWENDUNG: SCCM Schedule Tasks manuell triggern (Client-Actions sofort ausführen)",
			"  - Configuration Manager: Software Updates, Hardware Inventory, Policy Retrieval",
			"  - CIM-basiert: ROOT\\\\CCM Namespace + SMS_Client.TriggerSchedule Method",
			"  - Schedule IDs: Enum-Werte für verschiedene Client-Actions",
			"  - Sofortige Ausführung: Wartet nicht auf regulären Schedule",
			"  - Kein aktiver ADT Session erforderlich!",
			"",
			"  WORKFLOW:",
			"  1. ScheduleId als Enum-Wert empfangen",
			"  2. Enum zu GUID konvertieren (letzte 2 Bytes = ScheduleId)",
			"  3. Invoke-CimMethod auf ROOT\\\\CCM\\\\SMS_Client:",
			"     - MethodName: TriggerSchedule",
			"     - Arguments: sScheduleID (GUID-String mit 'b' Format)",
			"  4. ReturnValue prüfen:",
			"     - null = Method gab kein Resultat (ccmexec Problem?)",
			"     - 0 = Success",
			"     - != 0 = Error-Code",
			"",
			"  KRITISCH:",
			"  - SCCM Client: ccmexec.exe Service muss laufen!",
			"  - ScheduleId: ValidateSet Enum (TriggerScheduleId Type)",
			"  - GUID-Konvertierung: Letzten 2 Bytes = ScheduleId (BigEndian)",
			"  - CIM Namespace: ROOT\\\\CCM (nur auf SCCM Clients verfügbar)",
			"  - ReturnValue: null/0 = OK, andere Werte = Fehler",
			"  - Sofortige Ausführung: Cycle startet sofort (nicht scheduled)",
			"  Häufige Tasks: SoftwareUpdatesScan, HardwareInventory, SoftwareInventory, PolicyEvaluation",
			"  Deployment-Szenario: Nach Software-Installation → Force Policy Refresh",
			"  Troubleshooting: Client meldet nicht → Manual Inventory Trigger",
			"",
			"  SCHEDULE IDs (Beispiele):",
			"  - SoftwareUpdatesScan: Scan nach neuen Updates",
			"  - HardwareInventory: Hardware-Info an Server senden",
			"  - SoftwareInventory: Installierte Software melden",
			"  - MachinePolicyRetrievalEvaluation: Neue Policies holen + anwenden",
			"  - ApplicationDeploymentEvaluation: Application Deployments prüfen",
			"  - SoftwareUpdatesDeploymentEvaluation: Update Deployments auswerten",
			"  - DiscoveryDataCollection: Discovery-Daten sammeln",
			"  Siehe: https://learn.microsoft.com/en-us/mem/configmgr/develop/reference/core/clients/client-classes/triggerschedule-method-in-class-sms_client",
			"#>",
			"Invoke-ADTSCCMTask -ScheduleId ${1|SoftwareUpdatesScan,HardwareInventory,SoftwareInventory,MachinePolicyRetrievalEvaluation,ApplicationDeploymentEvaluation,SoftwareUpdatesDeploymentEvaluation,DiscoveryDataCollection|}$0"
		],
		"description": "Triggert SCCM Schedule Tasks manuell (CIM-basiert, ccmexec Client Actions)"
	},
	"mountwimfile": {
		"prefix": "mountwimfile",
		"body": [
			"# Native Alternative: Mount-WindowsImage (DISM Module)",
			"<#",
			"  VERWENDUNG: WIM-Dateien mounten (Windows Image Format - install.wim, boot.wim)",
			"  - Image Deployment: Windows-Installations-Images bearbeiten/anpassen",
			"  - Offline Servicing: Updates/Treiber in WIM injizieren ohne Boot",
			"  - Parameter Sets: Index (Imaj-Nummer) ODER Name (Imaj-Name)",
			"  - ReadOnly Mount: Schreibgeschützt (keine Änderungen möglich)",
			"  - CheckIntegrity: Prüft Image-Integrität beim Mount",
			"  - Kein aktiver ADT Session erforderlich!",
			"",
			"  WORKFLOW:",
			"  1. ImagePath validieren (existiert + kein UNC-Pfad)",
			"  2. Path validieren (leer/nicht existent + kein UNC + kein pre-mounted WIM)",
			"  3. Get-WindowsImage: Prüfe ob Index/Name existiert (Pre-Validation)",
			"  4. Pre-mounted Check: Warnung wenn WIM bereits woanders gemountet",
			"  5. Force-Logic:",
			"     - Path existiert + nicht leer + Force → Remove-Item -Force",
			"     - Path existiert + nicht leer + kein Force → FEHLER",
			"  6. Path erstellen falls nicht existent (CreateDirectory)",
			"  7. Mount-WindowsImage -ReadOnly -CheckIntegrity aufrufen",
			"  8. Bei aktivem ADTSession: AddMountedWimFile() (Tracking)",
			"  9. PassThru: Mount-WindowsImage Resultat zurückgeben",
			"",
			"  KRITISCH:",
			"  - ImagePath: Kein UNC-Pfad! (Network Shares nicht unterstützt)",
			"  - Path: Muss leer/nicht existent sein (außer -Force)",
			"  - ReadOnly: Immer! Keine Write-Operationen möglich",
			"  - Index vs Name: Nur EINES verwenden (Parameter Sets!)",
			"  - Pre-Validation: Get-WindowsImage vor Mount (schneller Fehler bei falschem Index)",
			"  - Multi-Mount: Gleiche WIM kann mehrmals gemountet werden (Warnung im Log)",
			"  - CheckIntegrity: Prüft Image-Korruption, kann Mount verlangsamen",
			"  - ADTSession Tracking: Bei aktivem Session wird mount getrackt (für Auto-Dismount)",
			"  Verwendung: Windows 10/11 Images anpassen, Treiber/Updates injizieren",
			"  Beispiel Index: install.wim hat mehrere Editionen (Home=1, Pro=2, Enterprise=3)",
			"  Beispiel Name: 'Windows 10 Pro' statt Index 2",
			"  Nach Mount: DISM mit /Image:MountPath für Servicing-Operationen",
			"  Wichtig: Immer Dismount-ADTWimFile nach Fertigstellung!",
			"#>",
			"Mount-ADTWimFile -ImagePath '${1:C:\\\\Images\\\\install.wim}' -Path '${2:C:\\\\Mount}' ${3|-Index ${4:1},-Name '${5:Windows 10 Pro}'|} ${6:-Force} ${7:-PassThru}$0"
		],
		"description": "Mountet WIM-Dateien ReadOnly (Windows Image, DISM-basiert, CheckIntegrity)"
	},
	"newerrorrecord": {
		"prefix": "newerrorrecord",
		"body": [
			"# Native Alternative: [System.Management.Automation.ErrorRecord]::new()",
			"<#",
			"  VERWENDUNG: ErrorRecord-Objekte erstellen (NUR für PSADT-Modul-Entwickler!)",
			"  - Custom Errors: Präzise Error-Informationen mit Category/TargetObject",
			"  - ThrowTerminatingError: Für \\$PSCmdlet.ThrowTerminatingError() vorbereiten",
			"  - CategoryInfo: Activity, TargetName, TargetType, Reason ausfüllen",
			"  - ErrorDetails: RecommendedAction für User-Guidance",
			"  - Kein aktiver ADT Session erforderlich!",
			"",
			"  WORKFLOW:",
			"  1. Exception-Objekt erstellen ([System.Exception]::new())",
			"  2. ErrorCategory wählen (NotSpecified, InvalidOperation, ResourceExists, etc.)",
			"  3. ErrorRecord instantiieren (Exception + ErrorId + Category + TargetObject)",
			"  4. Optional: CategoryInfo erweitern:",
			"     - Activity: Was wurde versucht? (z.B. 'Copying file')",
			"     - TargetName: Welches Objekt? (z.B. 'C:\\\\file.txt')",
			"     - TargetType: Objekttyp (z.B. 'File', 'Registry Key')",
			"     - Reason: Grund (z.B. 'Access Denied')",
			"  5. Optional: ErrorDetails mit RecommendedAction",
			"  6. ErrorRecord returnen (Caller wirft dann throw oder ThrowTerminatingError)",
			"",
			"  KRITISCH:",
			"  - NUR für PSADT-Modul-Entwickler! Normale Nutzer: throw/Write-Error direkt",
			"  - Exception: Muss \\$null sein (ValidateNotNullOrEmpty)",
			"  - Category: Enum System.Management.Automation.ErrorCategory",
			"  - ErrorId: Default 'NotSpecified' (besser: spezifische ID wie 'FileNotFoundError')",
			"  - TargetObject: Das betroffene Objekt (File path, Registry key, etc.)",
			"  - RecommendedAction: User-freundlicher Hinweis zur Lösung",
			"  - Return Value: ErrorRecord wird returned, NICHT geworfen!",
			"  Verwendung Pattern: \\$naerParams = @{...}; throw (New-ADTErrorRecord @naerParams)",
			"  Oder: \\$PSCmdlet.ThrowTerminatingError((New-ADTErrorRecord @naerParams))",
			"  ErrorCategory Beispiele: InvalidOperation, ObjectNotFound, PermissionDenied",
			"#>",
			"\\$naerParams = @{",
			"    Exception = [System.${1|InvalidOperationException,IO.FileNotFoundException,UnauthorizedAccessException,ArgumentException,PlatformNotSupportedException|}]::new('${2:Error message}')",
			"    Category = [System.Management.Automation.ErrorCategory]::${3|InvalidOperation,ObjectNotFound,PermissionDenied,ResourceExists,NotSpecified,InvalidArgument,InvalidData|}",
			"    ErrorId = '${4:CustomErrorId}'",
			"    TargetObject = ${5:\\$FilePath}",
			"    ${6:TargetName = '${7:FileName.txt}'}",
			"    ${8:TargetType = '${9:File}'}",
			"    ${10:Activity = '${11:Copying file}'}",
			"    ${12:Reason = '${13:Access Denied}'}",
			"    ${14:RecommendedAction = '${15:Please check file permissions and try again.}'}",
			"}",
			"${16|throw (New-ADTErrorRecord @naerParams),\\$PSCmdlet.ThrowTerminatingError((New-ADTErrorRecord @naerParams))|}$0"
		],
		"description": "Erstellt ErrorRecord-Objekte (für throw/ThrowTerminatingError, nur Modul-Entwickler)"
	},
	"newfolder": {
		"prefix": "newfolder",
		"body": [
			"# Native Alternative: New-Item -ItemType Directory -Force",
			"<#",
			"  VERWENDUNG: Ordner erstellen (mit automatischer Parent-Path-Erstellung)",
			"  - Idempotent: Existiert bereits → Log + kein Fehler",
			"  - Force-Modus: Parent-Paths werden automatisch erstellt (wie mkdir -p)",
			"  - Logging: Erstellt/Bereits vorhanden wird geloggt",
			"  - LiteralPath: Keine Wildcard-Expansion (sicherer für spezielle Zeichen)",
			"  - Kein aktiver ADT Session erforderlich!",
			"",
			"  WORKFLOW:",
			"  1. Test-Path: Prüfe ob Ordner bereits existiert",
			"  2. Falls JA: Log 'already exists' + return (kein Fehler!)",
			"  3. Falls NEIN:",
			"     - Log 'Creating folder'",
			"     - New-Item -ItemType Directory -Force",
			"     - Force erstellt automatisch Parent-Pfade",
			"  4. Bei Fehler: Invoke-ADTFunctionErrorHandler",
			"",
			"  KRITISCH:",
			"  - LiteralPath: Kein Wildcard! (*, ?, [...]) werden NICHT expandiert",
			"  - Path/PSPath: Alias für LiteralPath (3 Namen, gleiche Funktion)",
			"  - Force: Immer aktiv! Parent-Directories automatisch erstellt",
			"  - Idempotent: Mehrfach aufrufen = kein Problem (existiert schon = OK)",
			"  - Keine Ausgabe: Function returnt nichts (void)",
			"  - Logging: Immer! (ADTSession oder standalone)",
			"  Verwendung: Deployment-Ordner, Temp-Verzeichnisse, Log-Pfade erstellen",
			"  Beispiel Deep Path: 'C:\\\\Temp\\\\Deploy\\\\Logs\\\\2024\\\\02' → Alle Parents erstellt!",
			"  Vorteil vs New-Item: Automatisches Logging + Error-Handling + Idempotent",
			"#>",
			"New-ADTFolder -LiteralPath '${1:C:\\\\Temp\\\\DeploymentLogs}'$0"
		],
		"description": "Erstellt Ordner mit Auto-Parent-Erstellung (idempotent, Force-Modus, Logging)"
	},
	"New-ADTMsiTransform": {
		"prefix": "newmsitransform",
		"body": [
			"# Native: WindowsInstaller.Installer COM Object (sehr komplex!)",
			"<#",
			"  Verwendung: Erstellt .mst Transform-Datei für MSI-Anpassung (original MSI bleibt unverändert)",
			"  KRITISCH: Transform wird via msiexec angewendet: msiexec /i app.msi TRANSFORMS=custom.mst",
			"  MsiPath: Pfad zur Source MSI-Datei (Pflicht)",
			"  TransformProperties: Hashtable mit Property-Änderungen (Pflicht)",
			"  ApplyTransformPath: Existing .mst zuerst anwenden (Transform-Chaining)",
			"  NewTransformPath: Output-Pfad (optional, auto: <MsiPath>.mst oder <ApplyTransformPath>.new.mst)",
			"  Workflow: MSI kopieren → Properties ändern → GenerateTransform → .mst erstellen → Cleanup",
			"  Common Properties: ALLUSERS (1=per-machine, 0=per-user), REBOOT (ReallySuppress/Suppress/Force)",
			"  INSTALLDIR/TARGETDIR: Install-Pfad, PIDKEY/LICENSECODE: License-Key",
			"  ADDLOCAL: Features installieren (comma-separated), REMOVE: Features entfernen",
			"  Automatisches Cleanup: Temp-Dateien werden gelöscht, COM-Objekte released",
			"#>",
			"New-ADTMsiTransform `",
			"    -MsiPath \"$PSScriptRoot\\\\Files\\\\${1:app.msi}\" `",
			"    -TransformProperties @{",
			"        ALLUSERS = ${2|1,0|}",
			"        REBOOT = ${3|'ReallySuppress','Suppress','Force'|}",
			"        ${4:INSTALLDIR = '${5:C:\\\\Program Files\\\\MyApp}'}",
			"        ${6:AgreeToLicense = '${7:Yes}'}",
			"        ${8:ADDLOCAL = '${9:Feature1,Feature2}'}",
			"    }${10: `}",
			"    ${11:-NewTransformPath \"$PSScriptRoot\\\\Files\\\\${12:custom.mst}\"}$0"
		],
		"description": "Erstellt MSI Transform-Datei (.mst) für Deployment-Anpassungen"
	},
	"New-ADTShortcut": {
		"prefix": "newshortcut",
		"body": [
			"# Native: $WshShell = New-Object -ComObject WScript.Shell; $WshShell.CreateShortcut()",
			"<#",
			"  Verwendung: Erstellt Windows Shortcut (.lnk für Apps, .url für Web-Links)",
			"  KRITISCH: .lnk (Shell Link) → Full Features, .url (Internet Shortcut) → Nur TargetPath/Icon!",
			"  LiteralPath: Shortcut-Datei Pfad (muss .lnk oder .url enden)",
			"  TargetPath: Ziel (EXE/Folder für .lnk, URL für .url)",
			"  Arguments: Command-line Parameter (nur .lnk)",
			"  IconLocation: Icon-Datei Pfad (EXE/DLL/ICO)",
			"  IconIndex: Icon-Index in Datei (0-based, Standard: 0)",
			"  WorkingDirectory: Arbeitsverzeichnis (nur .lnk, %VAR% Support)",
			"  WindowStyle: Normal/Maximized/Minimized (nur .lnk)",
			"  RunAsAdmin: Als Administrator ausführen (nur .lnk, Byte 21 Flag 0x20)",
			"  Hotkey: Globaler Hotkey wie 'CTRL+SHIFT+F' (nur .lnk)",
			"  Auto-Features: Parent-Directory erstellen, existierende Shortcuts überschreiben",
			"#>",
			"New-ADTShortcut `",
			"    -LiteralPath \"${1:$env:Public\\\\Desktop\\\\${2:MyApp}.lnk}\" `",
			"    -TargetPath \"${3:$env:ProgramFiles\\\\${4:MyApp}\\\\${5:app.exe}}\" `",
			"    ${6:-Arguments '${7:/silent /norestart}'} `",
			"    ${8:-IconLocation \"${9:$env:ProgramFiles\\\\${10:MyApp}\\\\app.exe}\"} `",
			"    ${11:-IconIndex ${12:0}} `",
			"    ${13:-Description '${14:Launch MyApp}'} `",
			"    ${15:-WorkingDirectory '${16:%HOMEDRIVE%\\\\%HOMEPATH%}'} `",
			"    ${17:-WindowStyle ${18|Normal,Maximized,Minimized|}} `",
			"    ${19:-Hotkey '${20:CTRL+SHIFT+M}'} `",
			"    ${21:-RunAsAdmin}$0"
		],
		"description": "Erstellt Windows Shortcut (.lnk für Apps, .url für Web-Links)"
	},
	"New-ADTTemplate": {
		"prefix": "newtemplate",
		"body": [
			"# Native: Manuelles Copy-Item von Module + Frontend-Dateien (sehr komplex!)",
			"<#",
			"  Verwendung: Erstellt PSADT Deployment Package Template (ready-to-customize)",
			"  KRITISCH: Template = Scaffold mit Frontend-Script, Module, Config, Assets, Strings",
			"  Destination: Ziel-Pfad für Template (Standard: aktuelles Verzeichnis)",
			"  Name: Template-Ordnername (Standard: PSAppDeployToolkit_<Version>)",
			"  Version: 4 (v4 moderne Struktur) oder 3 (v3 Legacy-Kompatibilität) (Standard: 4)",
			"  Show: Template-Ordner in Explorer öffnen (Switch)",
			"  Force: Existierenden nicht-leeren Ordner löschen und neu erstellen (Switch)",
			"  PassThru: DirectoryInfo-Object zurückgeben (Switch)",
			"  Struktur v4: PSAppDeployToolkit/ im Root, Invoke-AppDeployToolkit.ps1, Config/, Assets/, Strings/",
			"  Struktur v3: AppDeployToolkit\\PSAppDeployToolkit/ (Legacy-Pfad)",
			"  Auto-Features: Digital Signature Removal, Module Read-Only Protection, Files/SupportFiles Ordner",
			"  Validation: Release Build Digital Signature Check (psd1 Dateien)",
			"#>",
			"New-ADTTemplate `",
			"    -Destination '${1:C:\\\\Deployments}' `",
			"    -Name '${2:MyApp_v1.0}' `",
			"    ${3:-Version ${4|4,3|}} `",
			"    ${5:-Show} `",
			"    ${6:-Force} `",
			"    ${7:-PassThru}$0"
		],
		"description": "Erstellt PSADT Deployment Package Template (v4/v3, ready-to-customize)"
	},
	"New-ADTValidateScriptErrorRecord": {
		"prefix": "newvalidatescripterrorrecord",
		"body": [
			"# Native: [System.Management.Automation.ErrorRecord]::new() mit ArgumentException",
			"<#",
			"  Verwendung: Erstellt ErrorRecord für Script Validation Fehler (Parameter-Validierung)",
			"  KRITISCH: Für ValidateScript-Blöcke und eigene PSADT-Funktionen!",
			"  ParameterName: Name des Parameters der validiert wird (Pflicht)",
			"  ProvidedValue: Ungültiger Wert der übergeben wurde (Pflicht, kann null sein)",
			"  ExceptionMessage: Fehlermeldung für User (Pflicht)",
			"  InnerException: Optional - Ursprungsfehler aus catch-Block (\\$_.Exception)",
			"  ErrorRecord Struktur: ArgumentException, Category=InvalidArgument, ErrorId='Invalid[Param]ParameterValue'",
			"  RecommendedAction: Auto-generiert als 'Review the supplied [ParameterName] parameter value and try again.'",
			"  TargetObject: ProvidedValue wird als TargetObject gesetzt",
			"  Verwendung: throw \\$errorRecord oder in ValidateScript-Block",
			"#>",
			"\\$${1:errorRecord} = New-ADTValidateScriptErrorRecord `",
			"    -ParameterName '${2:FilePath}' `",
			"    -ProvidedValue ${3:\\$FilePath} `",
			"    -ExceptionMessage '${4:Belirtilen yol bulunamadı}'${5: `}",
			"    ${6:-InnerException ${7:\\$_.Exception}}",
			"",
			"throw \\$${1:errorRecord}$0"
		],
		"description": "Erstellt ErrorRecord für Script Validation Fehler (ValidateScript, Parameter-Validierung)"
	},
	"New-ADTZipFile": {
		"prefix": "newzipfile",
		"body": [
			"# Native: Compress-Archive (aber ohne ACL-Fix für Session 0!)",
			"<#",
			"  Verwendung: Erstellt ZIP-Archiv oder fügt Inhalte zu bestehendem Archiv hinzu",
			"  KRITISCH: 2 ParameterSets - Path (Wildcards *,?) vs LiteralPath (literal) - nur EINS!",
			"  Path: Mit Wildcard-Support (*.log, App*.exe)",
			"  LiteralPath: Ohne Wildcard-Interpretation (für Dateinamen mit [, ], *, ?)",
			"  DestinationPath: Ziel-ZIP-Datei-Pfad (.zip Endung erforderlich!)",
			"  CompressionLevel: Fastest (schnell), Optimal (balanced), NoCompression (nur archivieren)",
			"  Update: Zu bestehendem ZIP hinzufügen (incremental backup)",
			"  Force: Bestehendes ZIP überschreiben (komplette Neuerstellung)",
			"  RemoveSourceAfterArchiving: Quell-Dateien nach Archivierung löschen (gefährlich!)",
			"  Auto-Features: Parent-Directory-Erstellung, ACL-Fix für Session 0 (SYSTEM)",
			"  WARNUNG: Force und Update können NICHT zusammen verwendet werden (Force hat Vorrang)!",
			"#>",
			"New-ADTZipFile `",
			"    -Path \"${1:C:\\\\Logs\\\\*.log}\" `",
			"    -DestinationPath \"${2:C:\\\\Archives\\\\Logs_$(Get-Date -Format 'yyyyMMdd').zip}\" `",
			"    ${3:-CompressionLevel ${4|Optimal,Fastest,NoCompression|}} `",
			"    ${5:-Update} `",
			"    ${6:-Force} `",
			"    ${7:-RemoveSourceAfterArchiving}$0"
		],
		"description": "Erstellt ZIP-Archiv oder fügt Inhalte hinzu (Wildcards, Compression, Auto-Cleanup)"
	},
	"Open-ADTSession": {
		"prefix": "opensession",
		"body": [
			"# Native: Keine - PSADT-spezifische Session-Initialisierung",
			"<#",
			"  Verwendung: Startet ADT Deployment Session (PFLICHT am Anfang jedes Deployments!)",
			"  KRITISCH: Singleton Pattern - nur eine aktive Session gleichzeitig!",
			"  DeploymentType: Install (Standard), Uninstall, Repair",
			"  DeployMode: Interactive (User-Dialoge), NonInteractive (Minimal UI), Silent (keine UI)",
			"  Auto-Detection: DeployMode wird automatisch erkannt wenn nicht angegeben (Session 0 → NonInteractive)",
			"  Zero-Config MSI: App-Infos werden automatisch aus MSI in Files-Ordner gelesen",
			"  AppVendor/AppName/AppVersion: Optional - für Reporting und Log-Dateiname",
			"  AppProcessesToClose: Processes die geschlossen werden müssen (optional, aus MSI extrahiert)",
			"  ScriptDirectory: Base-Directory (Standard: \\$PSScriptRoot)",
			"  TerminalServerMode: Für RDS/Citrix (Change User /Install)",
			"  RequireAdmin: Erzwingt Admin-Rechte (Error wenn nicht Admin)",
			"  DisableLogging: Deaktiviert Log-Datei (nur für Tests!)",
			"  Session-Callbacks: Führt OnStart, PreOpen Callbacks aus",
			"#>",
			"Open-ADTSession `",
			"    -DeploymentType ${1|Install,Uninstall,Repair|} `",
			"    -DeployMode ${2|Interactive,NonInteractive,Silent|} `",
			"    ${3:-AppVendor '${4:Microsoft}'} `",
			"    ${5:-AppName '${6:Office 365}'} `",
			"    ${7:-AppVersion '${8:2024}'} `",
			"    ${9:-ScriptDirectory \\$PSScriptRoot} `",
			"    ${10:-TerminalServerMode} `",
			"    ${11:-RequireAdmin} `",
			"    ${12:-DisableLogging} `",
			"    ${13:-PassThru}$0"
		],
		"description": "Startet ADT Deployment Session (PFLICHT, Zero-Config MSI, Auto-Detection)"
	},
	"Out-ADTPowerShellEncodedCommand": {
		"prefix": "OutePowerShellEncodedCommand",
		"body": [
			"# Native: [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(...))",
			"<#",
			".DESCRIPTION",
			"  PowerShell-Befehl in Base64 string encodieren für -EncodedCommand Parameter.",
			"  WICHTIG: Encoding ≠ Security! Base64 kann leicht decodiert werden.",
			"",
			".PARAMETER Command",
			"  Der zu encodierende PowerShell-Befehl (Pflicht)",
			"  Unterstützt: Einzelbefehle, Pipe-Chains, Multi-line Scripts, komplette Script-Dateien",
			"  Encoding: UTF-16LE → Base64",
			"",
			".USE CASES",
			"  ✓ Scheduled Tasks: Spezialzeichen-sichere Befehle",
			"  ✓ MECM/GPO: Detection Scripts & Deployment Commands encodieren",
			"  ✓ Remote Execution: PSExec, WMI, Invoke-Command ohne Command-Injection",
			"  ✓ Registry Storage: Scripts in Registry speichern",
			"  ✓ WMI Event Consumer: Persistence-Mechanismen",
			"  ✓ Multi-line → Single-line: Große Scripts als einzeiligen Befehl",
			"",
			".EXAMPLE",
			"  \\$encoded = Out-ADTPowerShellEncodedCommand -Command 'Get-Process | Where-Object { \\$_.CPU -gt 100 }'",
			"  powershell.exe -NoProfile -EncodedCommand \\$encoded",
			"",
			".NOTES",
			"  Command Line Limit: Max 8191 Zeichen (Encoding vergrößert um ~33%)",
			"  Format: UTF-16LE → Base64 (PowerShell Standard)",
			"  Sicherheit: NUR Transport-Sicherheit, KEINE Verschlüsselung!",
			"#>",
			"Out-ADTPowerShellEncodedCommand -Command ${1:'${2:Get-Process}'}$0"
		],
		"description": "PSADT: Encode PowerShell command to Base64 string"
	},
	"Register-ADTDll": {
		"prefix": "RegisterDll",
		"body": [
			"# Native: regsvr32.exe /s \"<DLL-Path>\"",
			"<#",
			".DESCRIPTION",
			"  Registriert COM DLL/ActiveX in Windows Registry (für Interop/Automation).",
			"  Nutzt regsvr32.exe im Hintergrund → ruft DllRegisterServer() auf.",
			"",
			".PARAMETER FilePath",
			"  Vollständiger Pfad zur .dll-Datei (Pflicht)",
			"  Validation: Datei muss existieren, .dll-Extension erforderlich",
			"",
			".ARCHITECTURE HANDLING",
			"  Auto-Detection: PSADT erkennt DLL-Bitness (32/64-bit) via PE Header",
			"  32-bit DLL → SysWOW64\\\\regsvr32.exe (64-bit OS) oder System32\\\\regsvr32.exe (32-bit OS)",
			"  64-bit DLL → System32\\\\regsvr32.exe (64-bit)",
			"  Silent Mode: /s Parameter (keine Dialoge, nur Exit Code)",
			"",
			".USE CASES",
			"  ✓ Legacy Apps: COM Components für alte Software registrieren",
			"  ✓ ActiveX Controls: IE/Web-basierte ActiveX-Controls",
			"  ✓ Custom COM Server: Eigene Automation Server (OLE, COM+)",
			"  ✓ Crystal Reports: Runtime DLLs für Reporting-Tools",
			"  ✓ Third-Party Components: PDF-Viewer, CAD-Controls, etc.",
			"  ✓ Repair Scenarios: Re-Registration bei beschädigten COM-Einträgen",
			"",
			".EXAMPLE",
			"  Register-ADTDll -FilePath \"\\$envProgramFiles\\\\MyApp\\\\Component.dll\"",
			"  Register-ADTDll -FilePath \"\\$DirFiles\\\\ActiveX.ocx\"",
			"",
			".NOTES",
			"  Funktionsweise: Lädt DLL → ruft DllRegisterServer() → schreibt CLSID/IID in Registry",
			"  Registry Paths: HKCR\\\\CLSID, HKCR\\\\Interface, HKCR\\\\TypeLib",
			"  Admin-Rechte: Meist erforderlich (HKLM-Schreibzugriff)",
			"  Fehler: Exit Code ≠ 0 → DLL nicht COM-kompatibel oder Dependency fehlt",
			"#>",
			"Register-ADTDll -FilePath ${1:'${2:\\$envProgramFiles\\\\MyApp\\\\Component.dll}'}$0"
		],
		"description": "PSADT: Register COM DLL/ActiveX with regsvr32 (Auto-Bitness)"
	},
	"Remove-ADTContentFromCache": {
		"prefix": "RemoveContentFromCache",
		"body": [
			"# Native: Remove-Item -Path <CachePath> -Recurse -Force",
			"<#",
			".DESCRIPTION",
			"  Löscht lokal gecachte Deployment-Dateien und setzt Session-Paths zurück.",
			"  Gegenstück zu Copy-ADTContentToCache - verwendet für Cleanup nach Install/Uninstall.",
			"",
			".PARAMETER LiteralPath",
			"  Cache-Ordner Pfad (Optional)",
			"  Standard: (Get-ADTConfig).Toolkit.CachePath\\\\(Get-ADTSession).InstallName",
			"  Typisch: C:\\\\Windows\\\\Temp\\\\PSAppDeployToolkit\\\\AppName_Version",
			"  Aliases: Path, PSPath",
			"",
			".BEHAVIOR",
			"  Cache löschen: Remove-Item -Recurse -Force auf angegebenen Pfad",
			"  Session Reset: \\$adtSession.DirFiles/DirSupportFiles → Original-Pfad",
			"  Wenn Cache nicht existiert: Keine Fehler, nur Log-Eintrag",
			"",
			".USE CASES",
			"  ✓ Uninstall Cleanup: Nach App-Deinstallation Cache entfernen",
			"  ✓ Post-Install: Speicherplatz freigeben (wenn kein Uninstall erwartet)",
			"  ✓ Version Upgrade: Alte Versionen-Cache vor neuem Install löschen",
			"  ✓ Failed Installation: Cleanup im Error-Handler",
			"  ✓ Intune Deployments: Manuelle Cache-Verwaltung (kein CCM Cache)",
			"  ✓ Scheduled Maintenance: Alte Cache-Ordner bereinigen (>30 Tage)",
			"",
			".EXAMPLE",
			"  Remove-ADTContentFromCache  # Verwendet Standard-Path",
			"  Remove-ADTContentFromCache -LiteralPath '\\$envWinDir\\\\Temp\\\\PSAppDeployToolkit\\\\MyApp_v1.0'",
			"",
			".NOTES",
			"  Intune-Kontext: Kein automatischer Cache wie ConfigMgr - manuelle Verwaltung nötig!",
			"  Best Practice: Install → Cache behalten, Uninstall → Cache löschen",
			"  Disk Space: Bei Platzmangel (<5GB) sofort nach Install löschen",
			"#>",
			"Remove-ADTContentFromCache${1: -LiteralPath '${2:\\$envWinDir\\\\Temp\\\\PSAppDeployToolkit\\\\MyApp}'}$0"
		],
		"description": "PSADT: Delete local cache folder and reset session paths"
	},
	"Remove-ADTDesktopShortcut": {
		"prefix": "RemoveDesktopShortcut",
		"body": [
			"# Native: Remove-Item -Path <ShortcutPath> -Force",
			"<#",
			".DESCRIPTION",
			"  HINWEIS: Keine dedizierte Remove-ADTDesktopShortcut Funktion in PSADT 4.1.8!",
			"  Stattdessen: Remove-ADTFile für .lnk/.url Dateien verwenden.",
			"",
			".PARAMETER LiteralPath",
			"  Vollständiger Pfad zur .lnk/.url Datei (exakt, keine Wildcards)",
			"  Für einzelne Shortcuts mit bekanntem Namen",
			"",
			".PARAMETER Path",
			"  Pfad mit Wildcard-Unterstützung (*) für mehrere ähnliche Shortcuts",
			"  Beispiel: '\\$envCommonDesktop\\\\MyApp*.lnk'",
			"",
			".PARAMETER Recurse",
			"  Für Start Menu Ordner: Löscht Ordner + alle Inhalte rekursiv",
			"",
			".SHORTCUT LOCATIONS",
			"  \\$envCommonDesktop → C:\\\\Users\\\\Public\\\\Desktop (alle User)",
			"  \\$envUserDesktop → C:\\\\Users\\\\[User]\\\\Desktop (aktueller User)",
			"  \\$envCommonStartMenuPrograms → Start Menu (alle User)",
			"  \\$envUserStartMenuPrograms → Start Menu (aktueller User)",
			"",
			".USE CASES",
			"  ✓ Uninstall Cleanup: App-Shortcuts nach Deinstallation entfernen",
			"  ✓ Orphan Shortcuts: Verwaiste Shortcuts (Target fehlt) bereinigen",
			"  ✓ Version Upgrade: Alte Versions-Shortcuts vor Neuinstallation löschen",
			"  ✓ Multi-Shortcuts: Wildcard für mehrere ähnliche Shortcuts (Office*, Adobe*)",
			"  ✓ Start Menu: Kompletten App-Ordner im Start-Menü entfernen",
			"  ✓ User Profiles: Remove-ADTFileFromUserProfiles für alle User-Desktops",
			"",
			".EXAMPLE",
			"  Remove-ADTFile -LiteralPath '\\$envCommonDesktop\\\\MyApp.lnk'",
			"  Remove-ADTFile -Path '\\$envCommonDesktop\\\\Office*.lnk'  # Wildcard",
			"  Remove-ADTFile -LiteralPath '\\$envCommonStartMenuPrograms\\\\Adobe' -Recurse",
			"",
			".NOTES",
			"  Funktion: Remove-ADTFile (universell für alle Dateitypen)",
			"  File Types: .lnk (Programme), .url (Websites)",
			"  Wenn nicht vorhanden: Nur Warning-Log, kein Fehler",
			"  Best Practice: Immer in Uninstall-Scripts Shortcuts aufräumen!",
			"#>",
			"Remove-ADTFile -LiteralPath ${1|'\\$envCommonDesktop','\\$envUserDesktop','\\$envCommonStartMenuPrograms'|}\\\\${2:MyApp.lnk}$0"
		],
		"description": "PSADT: Remove desktop/start menu shortcuts (using Remove-ADTFile)"
	},
	"Remove-ADTEdgeExtension": {
		"prefix": "RemoveEdgeExtension",
		"body": [
			"# Native: Get-ItemProperty + Set-ItemProperty (JSON-Manipulation: HKLM:\\\\SOFTWARE\\\\Policies\\\\...\\\\Edge\\\\ExtensionSettings)",
			"<#",
			".DESCRIPTION",
			"  Entfernt Microsoft Edge Extension aus ExtensionSettings Policy (Registry).",
			"  Verwendet für App-Uninstall oder Security-Policy Enforcement.",
			"",
			".PARAMETER ExtensionID",
			"  32-stellige Extension ID (Pflicht)",
			"  Format: Lowercase alphanumerisch (z.B. 'odfafepnkmbhccpbejgmiehpchacaeak')",
			"  ID finden: edge://extensions → Developer Mode → ID anzeigen",
			"",
			".REGISTRY LOCATION",
			"  Path: HKLM\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\Edge",
			"  Value: ExtensionSettings (JSON String)",
			"  Funktion entfernt Extension-ID aus JSON-Objekt",
			"",
			".USE CASES",
			"  ✓ Uninstall Cleanup: Extension bei App-Deinstallation entfernen",
			"  ✓ Security Policy: Verbotene Extensions blockieren/entfernen",
			"  ✓ Department Change: Alte Department-Extensions durch neue ersetzen",
			"  ✓ Version Upgrade: Alte Extension-ID entfernen, neue hinzufügen",
			"  ✓ Extension Reset: Alle managed Extensions für Clean-State entfernen",
			"  ✓ GPO Conflict Fix: Fehlerhafte Extension-Einträge korrigieren",
			"",
			".EXAMPLE",
			"  Remove-ADTEdgeExtension -ExtensionID 'odfafepnkmbhccpbejgmiehpchacaeak'  # uBlock Origin",
			"  Remove-ADTEdgeExtension -ExtensionID 'hdokiejnpimakedhajhdlcegeplioahd'  # LastPass",
			"",
			".NOTES",
			"  ⚠️ WARNUNG: NICHT mit Edge Management Service kombinieren (Registry-Konflikt)!",
			"  Wenn Extension nicht existiert: Sessile Return (kein Fehler)",
			"  Kompatibel mit: GPO/Intune Policies (verschiedene Extension-IDs)",
			"  Common IDs: uBlock Origin, LastPass, Grammarly, Microsoft Editor",
			"#>",
			"Remove-ADTEdgeExtension -ExtensionID '${1:odfafepnkmbhccpbejgmiehpchacaeak}'$0"
		],
		"description": "PSADT: Remove Microsoft Edge extension from ExtensionSettings policy"
	},
	"Remove-ADTEnvironmentVariable": {
		"prefix": "RemoveEnvironmentVariable",
		"body": [
			"# Native: [Environment]::SetEnvironmentVariable('VarName', \\$null, 'Machine/User/Process')",
			"<#",
			".DESCRIPTION",
			"  Löscht Environment Variable aus Machine/User/Process Scope.",
			"  Verwendet .NET SetEnvironmentVariable() mit null-Wert für Löschung.",
			"",
			".PARAMETER Variable",
			"  Name der zu löschenden Environment Variable (Pflicht)",
			"  Beispiele: JAVA_HOME, MAVEN_HOME, HTTP_PROXY, MY_APP_CONFIG",
			"  Case-insensitive: JAVA_HOME = java_home = Java_Home",
			"",
			".PARAMETER Target",
			"  Scope der Variable (Optional, Standard: Process)",
			"  Machine → Alle User (HKLM, Admin-Rechte erforderlich)",
			"  User → Aktueller User (HKCU, User-Rechte ausreichend)",
			"  Process → Nur aktuelle PowerShell-Session (temporär, kein Registry)",
			"",
			".SCOPE DETAILS",
			"  Machine: HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Session Manager\\\\Environment",
			"  User: HKCU\\\\Environment",
			"  Process: Nur RAM (verschwindet nach Session-Ende)",
			"",
			".USE CASES",
			"  ✓ Uninstall Cleanup: App-spezifische Variables entfernen (JAVA_HOME, etc.)",
			"  ✓ Security: Sensitive Daten löschen (API_KEY, SECRET_TOKEN)",
			"  ✓ Proxy Cleanup: HTTP_PROXY, HTTPS_PROXY, NO_PROXY entfernen",
			"  ✓ Legacy Cleanup: Alte Software-Reste bereinigen",
			"  ✓ Development Tool Cleanup: Dev-Tool Variables (MAVEN_HOME, NODE_HOME)",
			"  ✓ Test Cleanup: Temporäre Test-Variables entfernen",
			"",
			".EXAMPLE",
			"  Remove-ADTEnvironmentVariable -Variable 'JAVA_HOME' -Target Machine",
			"  Remove-ADTEnvironmentVariable -Variable 'HTTP_PROXY' -Target User",
			"  Remove-ADTEnvironmentVariable -Variable 'TEST_MODE'  # Process (default)",
			"",
			".NOTES",
			"  ⚠️ WARNUNG: Keine kritischen System-Variables löschen (PATH, TEMP, SYSTEMROOT)!",
			"  User Target: Benötigt aktiven User (in SYSTEM-Kontext → Bypass)",
			"  Variable nicht vorhanden: Kein Fehler (idempotent)",
			"  Admin-Rechte: Nur für Machine Target erforderlich",
			"#>",
			"Remove-ADTEnvironmentVariable `",
			"    -Variable '${1:JAVA_HOME}' `",
			"    ${2:-Target ${3|Machine,User,Process|}}$0"
		],
		"description": "PSADT: Delete environment variable from Machine/User/Process scope"
	},
	"Remove-ADTFile": {
		"prefix": "RemoveFile",
		"body": [
			"# Native: Remove-Item -Path <Path> -Force [-Recurse]",
			"<#",
			".DESCRIPTION",
			"  Löscht Dateien/Ordner mit Wildcard-Support und rekursiver Löschung.",
			"  ⚠️ PERMANENT! Kein Recycle Bin! Vorsicht bei -Recurse!",
			"",
			".PARAMETER Path / LiteralPath",
			"  Path: Wildcards erlaubt (*.log, *.tmp, Office*.lnk).",
			"  LiteralPath: Exakter Pfad ohne Wildcard (File[2024].xlsx, App (x86)).",
			"  Array: Mehrere Pfade: @('file1.txt', 'file2.log').",
			"",
			".PATH OPTIONS",
			"  Logs: *.log, *.tmp, *.bak, *.old.",
			"  Desktop: \\$envCommonDesktop\\\\*.lnk, \\$envUserDesktop\\\\MyApp.url.",
			"  Start Menu: \\$envCommonStartMenuPrograms\\\\MyApp\\\\*.lnk.",
			"  Temp: \\$envTemp\\\\*, \\$envWinDir\\\\Temp\\\\*.",
			"  Cache: \\$envLocalAppData\\\\MyApp\\\\Cache\\\\*.",
			"  ProgramData: \\$envProgramData\\\\MyApp\\\\*.log.",
			"",
			".PARAMETER Recurse",
			"  Löscht Ordner + gesamten Inhalt rekursiv.",
			"",
			".USE CASES",
			"  Log Cleanup, Desktop Shortcuts, Temp Files, Cache, Old Versions, Backup Files.",
			"#>",
			"Remove-ADTFile `",
			"    ${1|-Path,-LiteralPath|} ${2|'\\$envTemp\\\\*.log','\\$envTemp\\\\*.tmp','\\$envCommonDesktop\\\\MyApp.lnk','\\$envUserDesktop\\\\MyApp.lnk','\\$envCommonStartMenuPrograms\\\\MyApp\\\\*.lnk','\\$envLocalAppData\\\\MyApp\\\\Cache\\\\*','\\$envProgramData\\\\MyApp\\\\Logs\\\\*.log','\\$envWinDir\\\\Temp\\\\*.tmp','C:\\\\Logs\\\\*.log','C:\\\\Temp\\\\*.bak'|} `",
			"    ${3:-Recurse}$0"
		],
		"description": "PSADT: Delete files/folders with wildcard and recursive support"
	},
	"Remove-ADTFileFromUserProfiles": {
		"prefix": "RemoveFileFromUserProfiles",
		"body": [
			"# Native: Iteration über C:\\\\Users\\\\* + Remove-Item",
			"<#",
			".DESCRIPTION",
			"  Löscht Datei/Ordner aus ALLEN User Profilen.",
			"",
			".PARAMETER Path / LiteralPath",
			"  Relativer Pfad ab User-Root: 'AppData\\\\\\\\Roaming\\\\\\\\MyApp\\\\\\\\config.ini'",
			"  Wird zu: C:\\\\Users\\\\Username\\\\AppData\\\\Roaming\\\\MyApp\\\\config.ini",
			"",
			".PARAMETER ExcludeNTAccount",
			"  User ausschließen: 'DOMAIN\\\\\\\\Administrator'",
			"",
			".USE CASES",
			"  AppData Cleanup, Desktop Shortcuts, Admin Protection",
			"#>",
			"Remove-ADTFileFromUserProfiles `",
			"    ${1|-Path,-LiteralPath|} '${2:AppData\\\\\\\\Roaming\\\\\\\\MyApp\\\\\\\\config.ini}' `",
			"    ${3:-Recurse} `",
			"    ${4:-ExcludeNTAccount '${5:DOMAIN\\\\\\\\Admin}'}$0"
		],
		"description": "PSADT: Delete file/folder from ALL user profiles"
	},
	"Remove-ADTFolder": {
		"prefix": "RemoveFolder",
		"body": [
			"# Native: Remove-Item -Recurse -Force",
			"<#",
			".DESCRIPTION",
			"  Löscht Ordner. STANDARD: Recursive (alle Inhalte)! -DisableRecursion deaktiviert.",
			"  Unterstützt Pipeline (DirectoryInfo), Wildcards, Arrays.",
			"  ⚠️ PERMANENT! Standardmäßig rekursiv (alle Dateien + Unterordner)!",
			"",
			".PARAMETER Path / LiteralPath / InputObject",
			"  Path: Wildcards (*,?) erlaubt (Version_*, Temp*).",
			"  LiteralPath: Exakte Pfade (z.B. Folder[2024], App (x86)).",
			"  InputObject: Pipeline (Get-ChildItem | Remove-ADTFolder).",
			"  Array: Mehrere Ordner: @('C:\\\\\\\\Temp', 'C:\\\\\\\\Cache').",
			"",
			".PATH OPTIONS",
			"  Temp: \\$envTemp\\\\MyApp, \\$envWinDir\\\\Temp\\\\MyApp.",
			"  Cache: \\$envLocalAppData\\\\MyApp\\\\Cache.",
			"  ProgramData: \\$envProgramData\\\\MyApp\\\\Logs.",
			"  AppData: \\$envAppData\\\\MyApp, \\$envLocalAppData\\\\MyApp.",
			"  Old Versions: C:\\\\\\\\ProgramData\\\\\\\\MyApp\\\\\\\\Version_*.",
			"",
			".PARAMETER DisableRecursion",
			"  Nur Dateien + leere Subfolders löschen, nicht-leere Subfolders behalten.",
			"",
			".USE CASES",
			"  Temp/Cache Cleanup, Old Versions, Log Folders, Pipeline Cleanup, Wildcard Folders.",
			"#>",
			"Remove-ADTFolder `",
			"    ${1|-Path,-LiteralPath|} ${2|'\\$envTemp\\\\MyApp','\\$envLocalAppData\\\\MyApp\\\\Cache','\\$envProgramData\\\\MyApp\\\\Logs','\\$envProgramData\\\\MyApp\\\\Temp','\\$envAppData\\\\MyApp','\\$envWinDir\\\\Temp\\\\MyApp','C:\\\\\\\\ProgramData\\\\\\\\MyApp\\\\\\\\Version_*','C:\\\\\\\\Temp'|} `",
			"    ${3:-DisableRecursion}$0"
		],
		"description": "PSADT: Delete folder recursively (default) or selectively"
	},
	"Remove-ADTHashtableNullOrEmptyValues": {
		"prefix": "RemoveHashtableNullOrEmptyValues",
		"body": [
			"# Native: Manual filtering: .GetEnumerator() | Where { ![string]::IsNullOrWhiteSpace(\\$_.Value) }",
			"<#",
			".DESCRIPTION",
			"  Entfernt null/empty/whitespace Values aus Hashtable. Immutable: Gibt NEUE Hashtable zurück.",
			"",
			".PARAMETER Hashtable",
			"  Zu filternde Hashtable. Original bleibt unverändert.",
			"",
			".USE CASES",
			"  Splatting Cleanup: \\$clean = Remove... | Start-Process @clean",
			"  Registry: Nur valide Werte schreiben",
			"  API Body: JSON ohne null Fields",
			"#>",
			"\\$${1:cleanHashtable} = Remove-ADTHashtableNullOrEmptyValues `",
			"    -Hashtable ${2:\\$hashtable}$0"
		],
		"description": "PSADT: Clean hashtable by removing null/empty values"
	},
	"Remove-ADTIniSection": {
		"prefix": "RemoveIniSection",
		"body": [
			"# Native: Manuelle INI-Bearbeitung (Get-Content | Where | Set-Content)",
			"<#",
			".DESCRIPTION",
			"  Löscht gesamte Section [SectionName] + alle Keys aus INI-Datei.",
			"",
			".PARAMETER FilePath",
			"  INI-Datei Pfad. Muss existieren.",
			"",
			".PARAMETER Section",
			"  Section-Name (ohne Brackets). Z.B. 'Database' für [Database].",
			"",
			".USE CASES",
			"  Config Cleanup, Profile Reset, Legacy Migration, Multi-Tenant Removal",
			"#>",
			"Remove-ADTIniSection `",
			"    -FilePath '${1:C:\\\\\\\\ProgramData\\\\\\\\MyApp\\\\\\\\config.ini}' `",
			"    -Section '${2:Database}'$0"
		],
		"description": "PSADT: Delete entire INI section [Section] and all keys"
	},
	"Remove-ADTIniValue": {
		"prefix": "RemoveIniValue",
		"body": [
			"# Native: Manuelle INI-Bearbeitung (Get-Content | Where | Set-Content)",
			"<#",
			".DESCRIPTION",
			"  Löscht Key aus INI-Section. OHNE -Key: Löscht gesamte Section!",
			"",
			".PARAMETER FilePath",
			"  INI-Datei Pfad. Muss existieren.",
			"",
			".PARAMETER Section",
			"  Section-Name (ohne Brackets).",
			"",
			".PARAMETER Key",
			"  OPTIONAL! Mit Key: Nur Key löschen. OHNE Key: Gesamte Section löschen!",
			"",
			".USE CASES",
			"  Password Removal, Legacy Settings Cleanup, Conditional Deletion",
			"#>",
			"Remove-ADTIniValue `",
			"    -FilePath '${1:C:\\\\\\\\ProgramData\\\\\\\\MyApp\\\\\\\\config.ini}' `",
			"    -Section '${2:Database}' `",
			"    ${3:-Key '${4:Password}'}$0"
		],
		"description": "PSADT: Delete INI key or entire section (no -Key param)"
	},
	"Remove-ADTInvalidFileNameChars": {
		"prefix": "RemoveInvalidFileNameChars",
		"body": [
			"# Native: -replace with [IO.Path]::GetInvalidFileNameChars() regex",
			"<#",
			".DESCRIPTION",
			"  Entfernt ungültige Zeichen aus Dateinamen: < > : \" / \\\\ | ? * + Control-Chars.",
			"  Pipeline-Support: Mehrere Strings verarbeiten.",
			"",
			".PARAMETER Name",
			"  String mit potenziell ungültigen Zeichen. NUR Dateiname, NICHT kompletter Pfad!",
			"",
			".USE CASES",
			"  User Input Sanitization, Log File Naming (Timestamp hat ':'),",
			"  Database -> Filename, Download Sanitization",
			"#>",
			"\\$${1:safeFilename} = Remove-ADTInvalidFileNameChars `",
			"    -Name '${2:\\$userInput}'$0"
		],
		"description": "PSADT: Remove invalid filename characters from string"
	},
	"Remove-ADTModuleCallback": {
		"prefix": "RemoveModuleCallback",
		"body": [
			"# Native: Keine - Event-basiertes Hook-System (Custom Implementation)",
			"<#",
			".DESCRIPTION",
			"  Entfernt Callback-Funktion von Hookpoint. Session-ERFORDERLICH!",
			"",
			".PARAMETER Hookpoint",
			"  Enum: PreOpen, PostOpen, PreClose, PostClose, OnInit, OnStart, OnFinish, OnExit.",
			"",
			".PARAMETER Callback",
			"  CommandInfo Object(s) von Get-Command. Array unterstützt.",
			"",
			".USE CASES",
			"  Custom Logging Cleanup, Monitoring Removal, Error Handler Cleanup, Extension Deactivation",
			"#>",
			"Remove-ADTModuleCallback `",
			"    -Hookpoint ${1|PreOpen,PostOpen,PreClose,PostClose,OnInit,OnStart,OnFinish,OnExit|} `",
			"    -Callback ${2:\\$callbackCommand}$0"
		],
		"description": "PSADT: Remove callback function from hookpoint"
	},
	"Remove-ADTRegistryKey": {
		"prefix": "RemoveRegistryKey",
		"body": [
			"# Native: Remove-Item / Remove-ItemProperty",
			"<#",
			".DESCRIPTION",
			"  Löscht Registry-Key (OHNE -Name) oder Value (MIT -Name).",
			"  Subkeys? -Recurse erforderlich! Wildcards: -Path. Literal: -LiteralPath.",
			"",
			".PARAMETER Path / LiteralPath",
			"  Path: Wildcards erlaubt (HKLM:\\\\\\\\SOFTWARE\\\\\\\\MyApp\\\\\\\\*).",
			"  LiteralPath: Exakt, kein Wildcard. Alias: -Key.",
			"",
			".PATH OPTIONS",
			"  Uninstall: HKLM:\\\\\\\\SOFTWARE\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Uninstall\\\\\\\\MyApp.",
			"  Run/RunOnce: HKLM/HKCU Run, RunOnce.",
			"  AppPaths: HKLM:\\\\\\\\SOFTWARE\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\App Paths.",
			"  Custom: HKLM:\\\\\\\\SOFTWARE\\\\\\\\MyCompany\\\\\\\\MyApp.",
			"  User: HKCU:\\\\\\\\Software\\\\\\\\MyApp (mit -SID für alle User).",
			"",
			".PARAMETER Name",
			"  MIT Name: Value löschen. OHNE Name: Key löschen (+ -Recurse bei Subkeys).",
			"  (Default): Standard-Value löschen.",
			"",
			".NAME OPTIONS",
			"  Version, DisplayName, DisplayVersion, InstallLocation, UninstallString.",
			"  Publisher, InstallDate, ProductCode, Language, Config, Enabled.",
			"",
			".PARAMETER Recurse",
			"  Löscht Key + alle Subkeys rekursiv.",
			"",
			".PARAMETER Wow6432Node / SID",
			"  Wow6432Node: 32-bit Registry auf 64-bit System.",
			"  SID: HKCU->HKU\\\\\\\\SID Konvertierung (für alle User via Invoke-ADTAllUsersRegistryAction).",
			"",
			".USE CASES",
			"  Uninstall Cleanup, RunOnce Deletion, (Default) Value, All Users HKCU, Wildcard Subkeys.",
			"#>",
			"Remove-ADTRegistryKey `",
			"    ${1|-Path,-LiteralPath|} ${2|'HKLM:\\\\\\\\SOFTWARE\\\\\\\\MyApp','HKLM:\\\\\\\\SOFTWARE\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Uninstall\\\\\\\\MyApp','HKLM:\\\\\\\\SOFTWARE\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Run','HKCU:\\\\\\\\SOFTWARE\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Run','HKLM:\\\\\\\\SOFTWARE\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\RunOnce','HKCU:\\\\\\\\SOFTWARE\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\RunOnce','HKCU:\\\\\\\\Software\\\\\\\\MyApp','HKLM:\\\\\\\\SOFTWARE\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\App Paths\\\\\\\\MyApp.exe','HKLM:\\\\\\\\SOFTWARE\\\\\\\\MyApp\\\\\\\\*'|} `",
			"    ${3:-Name ${4|'Version','DisplayName','DisplayVersion','UninstallString','InstallLocation','ProductCode','Publisher','Config','Enabled','(Default)'|}} `",
			"    ${5:-Recurse} `",
			"    ${6:-Wow6432Node} `",
			"    ${7:-SID '${8:S-1-5-21-...}'}$0"
		],
		"description": "PSADT: Delete registry key or value (with -Recurse for subkeys)"
	},
	"Reset-ADTDeferHistory": {
		"prefix": "ResetDeferHistory",
		"body": [
			"# Native: Keine - PSADT Session-spezifisch (Registry-basiert)",
			"<#",
			".DESCRIPTION",
			"  Löscht Defer-History aus Registry. User kann wieder erneut deferrieren.",
			"  KEINE Parameter! Session ERFORDERLICH!",
			"",
			".USE CASES",
			"  Neue Deployment-Version: Alte Defer-Counts zurücksetzen",
			"  Post-Install: History aufräumen",
			"  Version Upgrade: Fresh Start für Deferral",
			"  Testing: Zwischen Tests zurücksetzen",
			"",
			".WICHTIG",
			"  Funktion wirft Fehler wenn KEINE aktive Session!",
			"#>",
			"Reset-ADTDeferHistory$0"
		],
		"description": "PSADT: Reset deferral counter in registry (session required)"
	},
	"Resolve-ADTErrorRecord": {
		"prefix": "ResolveErrorRecord",
		"body": [
			"# Native: \\$_.Exception | Format-List * -Force",
			"<#",
			".DESCRIPTION",
			"  Formatted String mit ErrorRecord-Details. Debugging & Logging.",
			"",
			".PARAMETER ErrorRecord",
			"  Catch-Block: \\$_ | Global: \\$Error[0] | Pipeline-Support.",
			"",
			".PARAMETER Property",
			"  Filter: -Property * (alle) | Message (single) | Message,Exception,... (array)",
			"  Default: Message, InnerException, FullyQualifiedErrorId, ScriptStackTrace, ...",
			"  Common: Message, Exception, InnerException, ScriptStackTrace, FullyQualifiedErrorId",
			"",
			".PARAMETER Exclude / Include",
			"  -ExcludeErrorRecord, -ExcludeErrorInvocation, -ExcludeErrorException",
			"  -IncludeErrorInnerException (Nested Exceptions)",
			"",
			".USE CASES",
			"  Catch-Block Logging, \\$Error Analysis, Inner Exception, Debugging",
			"#>",
			"\\$${1:errorDetails} = Resolve-ADTErrorRecord `",
			"    -ErrorRecord ${2:\\$_} `",
			"    ${3:-Property ${4|*,Message,Exception,InnerException,ScriptStackTrace,FullyQualifiedErrorId,TargetObject,PositionMessage|}} `",
			"    ${5:-IncludeErrorInnerException} `",
			"    ${6:-ExcludeErrorInvocation}$0"
		],
		"description": "PSADT: Get formatted error details from ErrorRecord"
	},
	"Send-ADTKeys": {
		"prefix": "SendKeys",
		"body": [
			"# Native: [System.Windows.Forms.SendKeys]::SendWait() - NACH Add-Type",
			"<#",
			".DESCRIPTION",
			"  Sendet Tastatureingaben an Window. NICHT in SYSTEM-Context (psexec -s -i nötig)!",
			"",
			".PARAMETER WindowTitle / WindowHandle",
			"  WindowTitle: Regex-Matching ('^Notepad\\$' für exakt)",
			"  WindowHandle: IntPtr von Get-ADTWindowTitle",
			"",
			".PARAMETER Keys",
			"  SendKeys-Syntax: {ENTER}, {TAB}, ^c (Ctrl+C), %{F4} (Alt+F4), +{TAB} (Shift+Tab)",
			"  Modifiers: ^ (Ctrl), % (Alt), + (Shift)",
			"",
			".PARAMETER WaitDuration",
			"  TimeSpan: New-TimeSpan -Seconds 5",
			"",
			".USE CASES",
			"  Dialog Automation ({ENTER}), App Close (Alt+F4), Save (Ctrl+S), Tab Navigation",
			"#>",
			"Send-ADTKeys `",
			"    ${1|-WindowTitle,-WindowHandle|} ${2|'.*Notepad\\$',\\$windowHandle|} `",
			"    -Keys '${3:{ENTER\\}}' `",
			"    ${4:-WaitDuration (New-TimeSpan -Seconds ${5:2})}$0"
		],
		"description": "PSADT: Send keyboard keys to application window (ActiveX)"
	},
	"Set-ADTActiveSetup": {
		"prefix": "SetActiveSetup",
		"body": [
			"# Native: New-Item + Set-ItemProperty (HKLM:\\\\\\\\SOFTWARE\\\\\\\\...\\\\\\\\Active Setup\\\\\\\\Installed Components\\\\\\\\{Key})",
			"<#",
			".DESCRIPTION",
			"  Per-User Registry/File-Änderungen bei jedem Login. HKLM->HKCU Replikation.",
			"  Native: New-Item -Path 'HKLM:\\\\\\\\...' | Set-ItemProperty -Name StubPath/Version",
			"",
			".PARAMETER StubExePath",
			"  Datei bei UserLogin: .exe, .vbs, .cmd, .bat, .ps1, .js",
			"  Auto-Copy: \\\\\\\\Files\\\\\\\\* -> Destination",
			"",
			".PARAMETER Version / Key",
			"  Version: yyMM,ddHH,mmss (Auto) oder Manual. Key: Eindeutiger Name.",
			"",
			".PARAMETER NoExecuteForCurrentUser / DisableActiveSetup / Purge",
			"  NoExecute: Nur zukünftige Logins. Disable: IsInstalled=0. Purge: LÖSCHEN (Uninstall).",
			"",
			".USE CASES",
			"  HKCU Registry (.reg), VBScript, PowerShell, PATH Update, Version Upgrade",
			"#>",
			"Set-ADTActiveSetup `",
			"    -StubExePath '${1:\\$env:ProgramData\\\\\\\\MyApp\\\\\\\\UserConfig.vbs}' `",
			"    ${2:-Arguments '${3:/Silent}'} `",
			"    ${4:-Description '${5:MyApp User Config}'} `",
			"    ${6:-Version '${7:1.0.0.0}'} `",
			"    ${8:-ExecutionPolicy ${9|Bypass,RemoteSigned,Unrestricted|}} `",
			"    ${10:-NoExecuteForCurrentUser} `",
			"    ${11:-DisableActiveSetup} `",
			"    ${12:-PurgeActiveSetupKey}$0"
		],
		"description": "PSADT: Create Active Setup entry for per-user login execution"
	},
	"Set-ADTDeferHistory": {
		"prefix": "SetDeferHistory",
		"body": [
			"# Native: Keine - PSADT Session Registry (DeferHistory Tracking)",
			"<#",
			".DESCRIPTION",
			"  Defer-Counter in Registry setzen. Session ERFORDERLICH!",
			"",
			".PARAMETER DeferTimesRemaining",
			"  Verbleibende Deferrals. Jedes Defer: -1. Bei 0: Kein Defer mehr.",
			"",
			".PARAMETER DeferDeadline",
			"  DateTime: Nach diesem Datum kein Defer möglich.",
			"",
			".PARAMETER DeferRunInterval",
			"  TimeSpan: Intune-Retry-Fix! Prozess läuft -> X Stunden warten bevor neuer Prompt.",
			"  Auto-Set: DeferRunIntervalLastTime (Get-Date)",
			"",
			".PARAMETER DeferRunIntervalLastTime",
			"  Manuelle DateTime für letztes Defer (normalerweise Auto).",
			"",
			".USE CASES",
			"  Remaining Update, Deadline Management, Intune Multi-Prompt Fix, Reset (=0)",
			"",
			".WICHTIG",
			"  Mind. 1 Parameter PFLICHT! Session ERFORDERLICH!",
			"#>",
			"Set-ADTDeferHistory `",
			"    ${1:-DeferTimesRemaining ${2:5}} `",
			"    ${3:-DeferDeadline (Get-Date).AddDays(${4:14})} `",
			"    ${5:-DeferRunInterval (New-TimeSpan -Hours ${6:4})} `",
			"    ${7:-DeferRunIntervalLastTime (Get-Date)}$0"
		],
		"description": "PSADT: Set deferral history in registry (times, deadline, interval)"
	},
	"Set-ADTEnvironmentVariable": {
		"prefix": "SetEnvironmentVariable",
		"body": [
			"# Native: [Environment]::SetEnvironmentVariable(name, value, target)",
			"<#",
			".DESCRIPTION",
			"  Environment Variable setzen. Target: Machine (HKLM), User (HKCU), Process (temp).",
			"",
			".PARAMETER Variable / Value",
			"  Variable: Name (z.B. PATH, JAVA_HOME). Value: String.",
			"",
			".PARAMETER Target",
			"  Machine: HKLM (Admin!), alle User. User: HKCU (ActiveUser, Client-Server). Process: Nur Session.",
			"",
			".USE CASES",
			"  Machine: COMPANY_NAME für alle. User: Preferences. PATH: Append. JAVA_HOME.",
			"  Remove: Value='' oder \\$null",
			"",
			".PATH MANAGEMENT",
			"  \\$path = [Environment]::GetEnvironmentVariable('PATH','Machine')",
			"  \\$new = \"\\$path;C:\\\\\\\\MyApp\\\\\\\\bin\"",
			"  Set-ADTEnvironmentVariable -Variable PATH -Value \\$new -Target Machine",
			"#>",
			"Set-ADTEnvironmentVariable `",
			"    -Variable '${1:COMPANY_NAME}' `",
			"    -Value '${2:Contoso Ltd}' `",
			"    ${3:-Target ${4|Machine,User,Process|}}$0"
		],
		"description": "PSADT: Set environment variable (Machine/User/Process scope)"
	},
	"Set-ADTIniSection": {
		"prefix": "SetIniSection",
		"body": [
			"# Native: Manuelle INI-Manipulation (Get/Set-Content + Parsing)",
			"<#",
			".DESCRIPTION",
			"  Gesamte Section mit Hashtable setzen. Merge (default) oder Overwrite (replace).",
			"",
			".PARAMETER FilePath / Section / Content",
			"  FilePath: INI-Pfad. Section: [SectionName] (ohne Brackets).",
			"  Content: Hashtable/OrderedDict @{Key1='Val1'; Key2='Val2'}",
			"",
			".PARAMETER Overwrite / Force",
			"  Overwrite: Section komplett ersetzen (alte Keys weg). Ohne: Merge (Keys erhalten).",
			"  Force: INI-Datei erstellen wenn nicht existiert.",
			"",
			".ORDERED HASHTABLE",
			"  [ordered]@{...} -> Reihenfolge beibehalten!",
			"",
			".USE CASES",
			"  Merge: Add/Update Keys. Overwrite: Replace All. Empty: Content=\\$null+Overwrite (Clear).",
			"  Force: Neue INI erstellen.",
			"#>",
			"Set-ADTIniSection `",
			"    -FilePath '${1:C:\\\\\\\\ProgramData\\\\\\\\MyApp\\\\\\\\config.ini}' `",
			"    -Section ${2|'Database','Logging','Application','Settings','Network'|} `",
			"    -Content ${3|@{Server='localhost';Port=3306},([ordered]@{Level='Info';Path='C:\\\\\\\\Logs'}),([ordered]@{Port=8080;Enabled=\\$true}),\\$null|} `",
			"    ${4:-Overwrite} `",
			"    ${5:-Force}$0"
		],
		"description": "PSADT: Set entire INI section with hashtable (merge or overwrite)"
	},
	"Set-ADTIniValue": {
		"prefix": "SetIniValue",
		"body": [
			"# Native: Manuelle INI-Manipulation (Get/Set-Content + Parsing)",
			"<#",
			".DESCRIPTION",
			"  Einzelne Key in INI-Section setzen. Precision Editing (andere Keys unberührt).",
			"",
			".PARAMETER FilePath / Section / Key / Value",
			"  FilePath: INI-Pfad. Section: [Name] (ohne Brackets).",
			"  Key: KeyName. Value: String (Boolean -> .ToString())",
			"",
			".PARAMETER Force",
			"  INI-Datei + Section + Key auto-create wenn nicht existiert.",
			"",
			".VALUE TYPES",
			"  String: 'Hello' -> Hello",
			"  Number: 123 -> 123",
			"  Boolean: \\$true.ToString() -> True",
			"  Empty: '' -> Key= (leer)",
			"",
			".USE CASES",
			"  Single Update, New Key, Notes KeyFileName, Empty Value, Multiple Sequential",
			"#>",
			"Set-ADTIniValue `",
			"    -FilePath '${1:C:\\\\\\\\ProgramData\\\\\\\\MyApp\\\\\\\\config.ini}' `",
			"    -Section '${2:Database}' `",
			"    -Key '${3:Server}' `",
			"    -Value '${4:localhost}' `",
			"    ${5:-Force}$0"
		],
		"description": "PSADT: Set single key-value in INI section"
	},
	"Set-ADTItemPermission": {
		"prefix": "SetItemPermission",
		"body": [
			"# Native: icacls.exe oder Get/Set-Acl (aber ohne Inheritance-Flags!)",
			"<#",
			".DESCRIPTION",
			"  NTFS-Berechtigungen (ACL) setzen. FullControl/Modify/Read/Write/Delete + Inheritance.",
			"",
			".PARAMETER LiteralPath / User / Permission",
			"  LiteralPath: Datei/Ordner-Pfad. User: 'DOMAIN\\\\User' oder 'BUILTIN\\\\Users' oder SID (*S-1-5-18).",
			"  Permission: FullControl, Modify, ReadAndExecute, Read, Write, Delete, None.",
			"",
			".PARAMETER PermissionType / Inheritance / Propagation",
			"  PermissionType: Allow (Standard) oder Deny.",
			"  Inheritance: ObjectInherit (Dateien erben), ContainerInherit (Ordner erben).",
			"  Propagation: None (Standard), InheritOnly (nur Kinder, nicht dieser Ordner), NoPropagateInherit (nur direkte Kinder).",
			"",
			".PARAMETER Method",
			"  AddAccessRule (hinzufügen), SetAccessRule (überschreiben), ResetAccessRule (zurücksetzen+hinzufügen), RemoveAccessRule (entfernen).",
			"",
			".PARAMETER DisableInheritance / EnableInheritance (❗ SEPARATE PARAMETERSETS!)",
			"  DisableInheritance: Vererbung vom Parent-Ordner unterbrechen (NICHT mit User/Permission kombinierbar!).",
			"  EnableInheritance: Vererbung vom Parent-Ordner aktivieren (NICHT mit User/Permission kombinierbar!).",
			"  RemoveExplicitRules: Explizite ACL-Regeln entfernen (nur mit Disable/EnableInheritance).",
			"",
			".PARAMETERSETS",
			"  1. SetPermission: -User -Permission [-PermissionType] [-Inheritance] [-Propagation] [-Method]",
			"  2. DisableInheritance: -DisableInheritance [-RemoveExplicitRules] (NUR DIESE PARAMETER!)",
			"  3. EnableInheritance: -EnableInheritance [-RemoveExplicitRules] (NUR DIESE PARAMETER!)",
			"",
			".USE CASES",
			"  Grant FullControl, Read-Only Users, Deny Delete, Remove All, Disable Inheritance, Enable Inheritance, SID-Based, Multiple Users.",
			"#>",
			"Set-ADTItemPermission `",
			"    -LiteralPath '${1:C:\\\\\\\\ProgramData\\\\\\\\MyApp}' `",
			"    -User ${2|'BUILTIN\\\\\\\\Users','BUILTIN\\\\\\\\Administrators','NT AUTHORITY\\\\\\\\SYSTEM','*S-1-5-18'|} `",
			"    -Permission ${3|FullControl,Modify,ReadAndExecute,Read,Write,Delete,DeleteSubdirectoriesAndFiles,ReadPermissions,ChangePermissions,TakeOwnership,None|} `",
			"    -PermissionType ${4|Allow,Deny|} `",
			"    -Inheritance ${5|ObjectInherit,ContainerInherit,'ObjectInherit,ContainerInherit'|} `",
			"    -Propagation ${6|None,InheritOnly,NoPropagateInherit|}$0"
		],
		"description": "PSADT: Set NTFS permissions (ACL) with inheritance"
	},
	"Set-ADTMsiProperty": {
		"prefix": "SetMsiProperty",
		"body": [
			"# Native: WindowsInstaller.Installer COM Object + OpenDatabase/Commit Methods",
			"<#",
			".DESCRIPTION",
			"  MSI database Property table'ında value set eder. UPDATE (varsa) veya INSERT (yoksa).",
			"",
			".PARAMETER Database / PropertyName / PropertyValue",
			"  Database: COM Object (Installer.OpenDatabase(path, 2)).",
			"  PropertyName: Property key (Scope: ALLUSERS, Paths: TARGETDIR/INSTALLDIR, ARP: ARPNOxxx, etc.).",
			"  PropertyValue: String value.",
			"",
			".WORKFLOW",
			"  1. MSI'yi OpenDatabase(path, 2) ile aç (ViewModifyUpdate mode).",
			"  2. Set-ADTMsiProperty ile property set et.",
			"  3. database.Commit() ile kaydet.",
			"  4. ReleaseComObject ile COM nesnelerini serbest bırak.",
			"",
			".USE CASES",
			"  Installation Scope: ALLUSERS=1 (per-machine), INSTALLLEVEL=100 (features).",
			"  Paths: TARGETDIR=CustomPath, INSTALLDIR=C:\\\\MyApp.",
			"  Add/Remove Programs: ARPNOMODIFY=1, ARPNOREPAIR=1, ARPHELPLINK=URL.",
			"  Reinstall: REINSTALLMODE=vomus, REINSTALL=ALL.",
			"  Advanced: TRANSFORMS=MyApp.mst, REBOOT=ReallySuppress.",
			"#>",
			"# MSI Database aç (Mode 2 = ViewModifyUpdate)",
			"\\$installer = New-Object -ComObject WindowsInstaller.Installer",
			"\\$database = \\$installer.OpenDatabase('${1:C:\\\\\\\\Temp\\\\\\\\MyApp.msi}', 2)",
			"",
			"# Property set et",
			"Set-ADTMsiProperty -Database \\$database -PropertyName '${2|ALLUSERS,ARPCOMMENTS,ARPCONTACT,ARPHELPLINK,ARPNOMODIFY,ARPNOREPAIR,ARPURLINFOABOUT,INSTALLDIR,INSTALLLEVEL,REBOOT,REINSTALL,REINSTALLMODE,TARGETDIR,TRANSFORMS|}' -PropertyValue '${3:1}'",
			"",
			"# Database commit + close",
			"\\$database.Commit()",
			"[System.Runtime.InteropServices.Marshal]::ReleaseComObject(\\$database) | Out-Null",
			"[System.Runtime.InteropServices.Marshal]::ReleaseComObject(\\$installer) | Out-Null$0"
		],
		"description": "PSADT: Set MSI database property (UPDATE/INSERT)"
	},
	"Set-ADTPowerShellCulture": {
		"prefix": "SetPSCulture",
		"body": [
			"# Native: [System.Threading.Thread]::CurrentThread.CurrentCulture = [System.Globalization.CultureInfo]::new('de-DE')",
			"<#",
			".DESCRIPTION",
			"  PowerShell Culture/UICulture setzen. Tarih, sayı formatı + hata mesaj dili.",
			"",
			".PARAMETER CultureInfo",
			"  IETF BCP 47 language tag: en-US, de-DE, tr-TR, fr-FR, ja-JP vb.",
			"",
			".CULTURE vs UICULTURE",
			"  Culture: Tarih, sayı, para formatı. UICulture: Hata mesajları, string resources.",
			"",
			".USE CASES",
			"  English Logs (en-US), German Regional (de-DE), Turkish (tr-TR), Date Format Switching, Error Message Localization, Multi-Region Auto-Detect.",
			"#>",
			"Set-ADTPowerShellCulture -CultureInfo ${1|'en-US','de-DE','tr-TR','fr-FR','ja-JP','es-ES'|}$0"
		],
		"description": "PSADT: Set PowerShell culture (date/number format + UI language)"
	},
	"Set-ADTRegistryKey": {
		"prefix": "SetRegKey",
		"body": [
			"# Native: New-Item / Set-ItemProperty (aber ohne SID/Wow6432Node Support!)",
			"<#",
			".DESCRIPTION",
			"  Registry Key/Value oluşturur veya set eder. SID + Wow6432Node + MultiString desteği.",
			"",
			".PARAMETER LiteralPath / Name / Value / Type",
			"  LiteralPath: Registry path (HKLM:\\\\SOFTWARE\\\\...). Name: Value name ('(Default)' için default).",
			"  Value: Data. Type: String, DWord, QWord, Binary, MultiString, ExpandString.",
			"",
			".PARAMETER MultiStringValueMode",
			"  Replace (default): Tümünü değiştir. Add: Ekle (duplicate yok). Remove: Belirtilenleri çıkar.",
			"",
			".PARAMETER Wow6432Node / SID / RegistryOptions",
			"  Wow6432Node: 32-bit registry (64-bit sistemde).",
			"  SID: User-specific (HKCU -> HKU\\\\\\\\SID).",
			"  RegistryOptions: Volatile (reboot'ta silinir) gibi options.",
			"",
			".USE CASES",
			"  Application Info: Version/DisplayName/Publisher/Manufacturer.",
			"  Paths: InstallPath/InstallLocation/InstallDir.",
			"  Uninstall: UninstallString/DisplayVersion/ProductCode.",
			"  Configuration: Enabled/EnableAutoUpdate/Config/Status/Language.",
			"  Advanced: Default Value '(Default)', MultiString, Wow6432Node, SID-Based.",
			"#>",
			"Set-ADTRegistryKey `",
			"    -LiteralPath '${1:HKLM:\\\\\\\\SOFTWARE\\\\\\\\MyCompany\\\\\\\\MyApp}' `",
			"    -Name '${2|(Default),Config,DisplayName,DisplayVersion,Enabled,EnableAutoUpdate,InstallDir,InstallLocation,InstallPath,Language,Manufacturer,Path,ProductCode,Publisher,Status,UninstallString,URL,Version|}' `",
			"    -Value ${3:'1.0.0'} `",
			"    -Type ${4|String,DWord,QWord,Binary,MultiString,ExpandString|}${5: ``}",
			"${6:    #-MultiStringValueMode ${7|Replace,Add,Remove|} ``}",
			"${8:    #-Wow6432Node ``}",
			"${9:    #-RegistryOptions ${10|None,Volatile|} ``}",
			"${11:    #-SID '${12:S-1-5-21-...}'}$0"
		],
		"description": "PSADT: Create or set registry key/value (SID + Wow6432Node + MultiString)"
	},
	"Set-ADTServiceStartMode": {
		"prefix": "SetServiceStartMode",
		"body": [
			"# Native: Set-Service -StartupType (aber erkennt kein 'Delayed Start'!)",
			"<#",
			".DESCRIPTION",
			"  Windows servis startup mode setzen. sc.exe backend (WMI yerine, Delayed Start desteği).",
			"",
			".PARAMETER Service / StartMode",
			"  Service: ServiceController object (Get-Service ile).",
			"  StartMode: Automatic, 'Automatic (Delayed Start)', Manual, Disabled, Boot, System.",
			"",
			".STARTMODE OPTIONS",
			"  Automatic: Hemen başlat (boot). Delayed: ~2dk gecikme. Manual: On-demand. Disabled: Devre dışı.",
			"  Boot: Kernel driver (OS loader). System: Kernel driver (OS init).",
			"",
			".USE CASES",
			"  Disable Service, Enable Automatic, Delayed Start (SQL), Manual Mode, Multiple Services (Telemetry), Service Dependency.",
			"#>",
			"\\$service = Get-Service -Name '${1:wuauserv}'",
			"Set-ADTServiceStartMode -Service \\$service -StartMode ${2|'Automatic','Automatic (Delayed Start)','Manual','Disabled','Boot','System'|}$0"
		],
		"description": "PSADT: Set Windows service startup mode (sc.exe backend)"
	},
	"Show-ADTBalloonTip": {
		"prefix": "ShowBalloonTip",
		"body": [
			"# Native: (New-Object -ComObject WScript.Shell).Popup() oder [System.Windows.Forms.NotifyIcon] mit .ShowBalloonTip()",
			"# Windows 10+: Wird automatisch zu Toast Notification konvertiert",
			"<#",
			".DESCRIPTION",
			"  Zeigt Balloon Tip Notification im System Tray (Windows 10+: Toast Notification).",
			"  Funktioniert NICHT im Silent Mode (außer mit -Force).",
			"",
			".PARAMETER BalloonTipText",
			"  Haupttext der Notification (erforderlich).",
			"",
			".PARAMETER BalloonTipTitle",
			"  Titel der Notification. Standard: \\$adtSession.InstallTitle (falls Session aktiv).",
			"",
			".TEXT OPTIONS (aus strings.psd1 - BalloonTip)",
			"  Start: Installation/Repair/Uninstallation started.",
			"  Complete: Installation/Repair/Uninstallation complete.",
			"  RestartRequired: Installation/Repair/Uninstallation complete. A reboot is required.",
			"  Error: Installation/Repair/Uninstallation failed.",
			"  FastRetry: Installation/Repair/Uninstallation not complete.",
			"",
			".PARAMETER BalloonTipIcon",
			"  Icon: Error, Info (Standard), None, Warning.",
			"",
			".PARAMETER BalloonTipTime",
			"  Anzeigedauer in Millisekunden. Standard: 10000 (10 Sekunden).",
			"",
			".PARAMETER NoWait / Force",
			"  NoWait: Asynchron (nicht blockierend).",
			"  Force: Zeigt Notification auch im Silent Mode.",
			"",
			".USE CASES",
			"  Deployment Start/Complete Notifications, Restart Warnings, Error Alerts, Repair Operations.",
			"#>",
			"Show-ADTBalloonTip `",
			"    -BalloonTipText ${1|'Installation started.','Installation complete.','Installation complete. A reboot is required.','Installation failed.','Uninstallation started.','Uninstallation complete.','Installation not complete.'|} `",
			"    ${2:-BalloonTipTitle '${3:MyApp}' ``}",
			"    ${4:-BalloonTipIcon ${5|Info,Warning,Error,None|} ``}",
			"    ${6:-BalloonTipTime ${7:10000} ``}",
			"    ${8:-NoWait} `",
			"    ${9:-Force}$0"
		],
		"description": "PSADT: Show balloon tip notification (Windows 10+: Toast)"
	},
	"Set-ADTShortcut": {
		"prefix": "SetShortcut",
		"body": [
			"# Native: COM WScript.Shell - \\$shell = New-Object -ComObject WScript.Shell; \\$shortcut = \\$shell.CreateShortcut(\\$path); \\$shortcut.TargetPath = ...; \\$shortcut.Save()",
			"<#",
			".DESCRIPTION",
			"  Ändert bestehende Shortcuts (.lnk/.url) mit konfigurierbaren Optionen.",
			"  Nur angegebene Parameter werden geändert, andere bleiben unverändert.",
			"",
			".PARAMETER LiteralPath",
			"  Pfad zum existierenden Shortcut (muss .lnk oder .url sein).",
			"",
			".PATH OPTIONS",
			"  Desktop: \\$envCommonDesktop\\\\*.lnk, \\$envUserDesktop\\\\MyApp.lnk.",
			"  Start Menu: \\$envCommonStartMenuPrograms\\\\MyApp\\\\*.lnk.",
			"  Startup: \\$envCommonStartup\\\\MyApp.lnk.",
			"",
			".PARAMETER TargetPath / Arguments",
			"  TargetPath: Ziel-Pfad oder URL die der Shortcut startet.",
			"  Arguments: Parameter für TargetPath.",
			"",
			".PARAMETER IconLocation / IconIndex",
			"  IconLocation: Icon-Datei (.ico, .exe, .dll).",
			"  IconIndex: Icon-Index (0-basiert, bei .exe/.dll mit mehreren Icons).",
			"",
			".PARAMETER Description / WorkingDirectory",
			"  Description: Beschreibung in Shortcut-Properties.",
			"  WorkingDirectory: Arbeitsverzeichnis für TargetPath.",
			"",
			".PARAMETER WindowStyle",
			"  Normal (1), Maximized (3), Minimized (7), DontChange (Standard).",
			"",
			".PARAMETER RunAsAdmin / Hotkey",
			"  RunAsAdmin: Erfordert Administrator-Rechte.",
			"  Hotkey: z.B. 'CTRL+SHIFT+F'.",
			"",
			".USE CASES",
			"  Update Target Path, Change Icon, Set Admin Rights, Change Arguments, Update Description.",
			"#>",
			"Set-ADTShortcut `",
			"    -LiteralPath ${1|'\\$envCommonDesktop\\\\MyApp.lnk','\\$envUserDesktop\\\\MyApp.lnk','\\$envCommonStartMenuPrograms\\\\MyApp\\\\MyApp.lnk','\\$envCommonStartup\\\\MyApp.lnk'|} `",
			"    ${2:-TargetPath '${3:\\$envProgramFiles\\\\MyApp\\\\MyApp.exe}' ``}",
			"    ${4:-Arguments '${5:/silent}' ``}",
			"    ${6:-IconLocation '${7:\\$envProgramFiles\\\\MyApp\\\\MyApp.exe}' ``}",
			"    ${8:-IconIndex ${9:0} ``}",
			"    ${10:-Description '${11:MyApp Application}' ``}",
			"    ${12:-WorkingDirectory '${13:\\$envProgramFiles\\\\MyApp}' ``}",
			"    ${14:-WindowStyle ${15|Normal,Maximized,Minimized,DontChange|} ``}",
			"    ${16:-RunAsAdmin} `",
			"    ${17:-Hotkey '${18:CTRL+SHIFT+F}'}$0"
		],
		"description": "PSADT: Modify existing .lnk or .url shortcuts"
	},
	"Show-ADTDialogBox": {
		"prefix": "ShowDialogBox",
		"body": [
			"# Native: [System.Windows.Forms.MessageBox]::Show() veya (New-Object -ComObject WScript.Shell).Popup()",
			"<#",
			".DESCRIPTION",
			"  Zeigt einfache MessageBox-Style Dialog mit Buttons, Icon, Timeout.",
			"  EMPFEHLUNG: Nutze Show-ADTInstallationPrompt für besseres Branding!",
			"",
			".PARAMETER Text",
			"  Nachrichtentext im Dialog (erforderlich).",
			"",
			".TEXT OPTIONS",
			"  Installation will take 30 minutes. Proceed?, Do you want to continue?",
			"  Please close application before continuing, Configuration will be updated.",
			"",
			".PARAMETER Title",
			"  Dialog-Titel. Standard: \\$adtSession.InstallTitle.",
			"",
			".PARAMETER Buttons",
			"  Ok, OkCancel, YesNo, YesNoCancel, RetryCancel, AbortRetryIgnore.",
			"",
			".PARAMETER DefaultButton",
			"  First (Standard), Second, Third.",
			"",
			".PARAMETER Icon",
			"  None (Standard), Stop, Question, Exclamation, Information.",
			"",
			".PARAMETER Timeout",
			"  Timeout in Sekunden. Standard: config.psd1 UI.DefaultTimeout.",
			"",
			".PARAMETER NoWait / ExitOnTimeout / NotTopMost / Force",
			"  NoWait: Asynchron (nicht blockierend).",
			"  ExitOnTimeout: Skript beenden bei Timeout.",
			"  NotTopMost: Dialog nicht im Vordergrund.",
			"  Force: Zeigt Dialog auch im Silent Mode.",
			"",
			".USE CASES",
			"  Yes/No Prompts, OK/Cancel Dialogs, Simple Notifications, Timeout Dialogs.",
			"#>",
			"\\$result = Show-ADTDialogBox `",
			"    -Text ${1|'Installation will take approximately 30 minutes. Do you wish to proceed?','Do you want to continue with the installation?','Please close all applications before continuing.','Configuration will be updated. Continue?'|} `",
			"    ${2:-Title '${3:Installation Notice}' ``}",
			"    ${4:-Buttons ${5|Ok,OkCancel,YesNo,YesNoCancel,RetryCancel,AbortRetryIgnore|} ``}",
			"    ${6:-DefaultButton ${7|First,Second,Third|} ``}",
			"    ${8:-Icon ${9|None,Information,Question,Exclamation,Stop|} ``}",
			"    ${10:-Timeout ${11:600} ``}",
			"    ${12:-NoWait} `",
			"    ${13:-ExitOnTimeout} `",
			"    ${14:-NotTopMost} `",
			"    ${15:-Force}",
			"",
			"# Result: Button text clicked (e.g., 'OK', 'Yes', 'No', 'Cancel', 'Timeout')",
			"Write-ADTLogEntry \"User clicked: \\$result\"$0"
		],
		"description": "PSADT: Show simple message dialog box with buttons and icon"
	},
	"Show-ADTHelpConsole": {
		"prefix": "ShowHelpConsole",
		"body": [
			"# Native: Get-Command -Module PSAppDeployToolkit | Out-GridView -PassThru | ForEach-Object { Get-Help \\$_ -Full }",
			"<#",
			".DESCRIPTION",
			"  Öffnet ADT Help Console in neuem PowerShell-Fenster.",
			"  Grafische Übersicht aller ADT-Befehle mit vollständiger Hilfe.",
			"  Keine Parameter erforderlich!",
			"",
			".FEATURES",
			"  - ListBox mit allen ADT-Befehlen",
			"  - TextBox mit vollständiger Get-Help Ausgabe",
			"  - Durchsuchbar und filterbar",
			"  - Separate PowerShell-Instanz (nicht blockierend)",
			"",
			".USE CASES",
			"  Schnelle Referenz, Syntax-Lookup, Parameter-Übersicht, Beispiele finden.",
			"#>",
			"Show-ADTHelpConsole$0"
		],
		"description": "PSADT: Open help console in new PowerShell window"
	},
	"Show-ADTInstallationProgress": {
		"prefix": "ShowInstallationProgress",
		"body": [
			"# Native: Write-Progress -Activity \"Installing...\" -Status \"Please wait...\" -PercentComplete 50",
			"<#",
			".DESCRIPTION",
			"  Zeigt Progress-Dialog in separatem Thread mit aktualisierbarer Nachricht.",
			"  Marquee-Style (endlos) oder Prozentangabe möglich.",
			"  Beim ERSTEN Aufruf: Balloon Tip 'Installation Started' (config.psd1).",
			"",
			".PARAMETER StatusMessage",
			"  Hauptnachricht im Dialog. Standard: strings.psd1 ProgressPrompt.Message.",
			"",
			".MESSAGE OPTIONS",
			"  Installation in Progress..., Configuring settings..., Copying files...",
			"  Please wait while setup completes, Removing old version..., Installing updates...",
			"",
			".PARAMETER StatusMessageDetail",
			"  Detail-Nachricht (nur Fluent-Style). Standard: strings.psd1 MessageDetail.",
			"",
			".PARAMETER StatusBarPercentage",
			"  Prozentangabe (0-100). NULL = Marquee (endlos scrollend).",
			"",
			".PARAMETER Title / Subtitle",
			"  Title: Dialog-Titel. Standard: \\$adtSession.InstallTitle.",
			"  Subtitle: Untertitel (Fluent). Standard: strings.psd1.",
			"",
			".PARAMETER MessageAlignment",
			"  Center (Standard), Left, Right. NUR Classic-Style! (Fluent ignoriert).",
			"",
			".PARAMETER WindowLocation",
			"  Default, BottomLeft, BottomRight, TopLeft, TopRight, TopCenter, BottomCenter.",
			"",
			".PARAMETER NotTopMost / AllowMove",
			"  NotTopMost: Dialog nicht im Vordergrund.",
			"  AllowMove: User kann Dialog verschieben.",
			"",
			".UPDATE PROGRESS",
			"  ERSTER Aufruf: ÖFFNET Dialog.",
			"  NACHFOLGENDE Aufrufe: AKTUALISIEREN Dialog (nur neue Parameter).",
			"  Close-ADTInstallationProgress: Schließt Dialog.",
			"",
			".USE CASES",
			"  Installation Progress, File Copy Progress, Configuration Progress, Multi-Step Progress.",
			"#>",
			"# Öffne Progress Dialog (erster Aufruf)",
			"Show-ADTInstallationProgress `",
			"    -StatusMessage ${1|'Installation in Progress...','Configuring settings...','Copying files...','Please wait while setup completes','Removing old version...','Installing updates...'|} `",
			"    ${2:-StatusMessageDetail '${3:This may take several minutes}' ``}",
			"    ${4:#-StatusBarPercentage ${5:50} ``}",
			"    ${6:-Title '${7:MyApp Installation}' ``}",
			"    ${8:-WindowLocation ${9|Default,BottomLeft,BottomRight,TopLeft,TopRight,TopCenter,BottomCenter|} ``}",
			"    ${10:-MessageAlignment ${11|Center,Left,Right|} ``}",
			"    ${12:-NotTopMost} `",
			"    ${13:-AllowMove}",
			"",
			"# Update Progress (nachfolgende Aufrufe)",
			"${14:#Show-ADTInstallationProgress -StatusMessage 'Step 2: Installing components...' -StatusBarPercentage 75}",
			"",
			"# Close Progress",
			"${15:#Close-ADTInstallationProgress}$0"
		],
		"description": "PSADT: Show/update progress dialog in separate thread"
	},
	"Show-ADTInstallationPrompt": {
		"prefix": "ShowInstallationPrompt",
		"body": [
			"# Native: [System.Windows.Forms.MessageBox]::Show() veya custom WPF/WinForms window",
			"<#",
			".DESCRIPTION",
			"  Zeigt benutzerdefinierten Dialog mit Toolkit-Branding und Buttons.",
			"  Flexible Button-Kombinationen, Icons, Timeout, Persist, Input-Feld.",
			"  Return Value = geklickter Button-Text.",
			"",
			".PARAMETER Message",
			"  Nachrichtentext im Dialog (erforderlich).",
			"",
			".MESSAGE OPTIONS",
			"  Do you want to proceed?, Please close all applications, Installation complete.",
			"  Custom configuration required, Save your work before continuing.",
			"",
			".PARAMETER RequestInput / DefaultValue",
			"  RequestInput: Zeigt Textfeld für User-Eingabe.",
			"  DefaultValue: Vorbelegter Wert im Textfeld.",
			"",
			".PARAMETER Title / Subtitle",
			"  Title: Dialog-Titel. Standard: \\$adtSession.InstallTitle.",
			"  Subtitle: Untertitel (Fluent). Standard: strings.psd1.",
			"",
			".PARAMETER ButtonRightText / ButtonLeftText / ButtonMiddleText",
			"  ButtonRightText: Rechter Button (häufig 'OK', 'Yes', 'Submit').",
			"  ButtonLeftText: Linker Button (häufig 'Cancel', 'No').",
			"  ButtonMiddleText: Mittlerer Button (3-Button-Dialog).",
			"  WICHTIG: Mind. 1 Button erforderlich!",
			"",
			".BUTTON OPTIONS",
			"  Common: OK, Cancel, Yes, No, Submit, Close, Continue, Skip, Abort.",
			"  Custom: Beliebiger Text möglich!",
			"",
			".PARAMETER Icon",
			"  None, Application, Asterisk, Error, Exclamation, Hand, Information, Question, Shield, Warning, WinLogo.",
			"  NUR Classic-Style! Fluent ignoriert Icons.",
			"",
			".PARAMETER MessageAlignment",
			"  Center (Standard), Left, Right. NUR Classic-Style!",
			"",
			".PARAMETER WindowLocation",
			"  Default, BottomLeft, BottomRight, TopLeft, TopRight, TopCenter, BottomCenter.",
			"",
			".PARAMETER Timeout",
			"  Timeout in Sekunden. Standard: config.psd1 UI.DefaultTimeout.",
			"",
			".PARAMETER NoWait / PersistPrompt / MinimizeWindows",
			"  NoWait: Asynchron (nicht blockierend). NUR ohne RequestInput!",
			"  PersistPrompt: Dialog re-appears alle X Sekunden (config.psd1 PromptPersistInterval).",
			"  MinimizeWindows: Minimiert andere Fenster beim Anzeigen.",
			"",
			".PARAMETER NoExitOnTimeout / NotTopMost / AllowMove / Force",
			"  NoExitOnTimeout: Skript NICHT beenden bei Timeout.",
			"  NotTopMost: Dialog nicht im Vordergrund.",
			"  AllowMove: User kann Dialog verschieben.",
			"  Force: Zeigt Dialog auch im Silent Mode.",
			"",
			".USE CASES",
			"  Yes/No Prompts, User Input, Multi-Button Dialogs, Persistent Prompts, Custom Notifications.",
			"#>",
			"\\$result = Show-ADTInstallationPrompt `",
			"    -Message ${1|'Do you want to proceed with the installation?','Please close all applications before continuing.','Installation completed successfully.','Custom configuration required. Please provide input.','Save your work before continuing.'|} `",
			"    ${2:-Title '${3:Installation Notice}' ``}",
			"    ${4:#-Subtitle '${5:MyApp Deployment}' ``}",
			"    ${6:-ButtonRightText ${7|'OK','Yes','Submit','Continue','Close'|} ``}",
			"    ${8:#-ButtonLeftText ${9|'Cancel','No','Skip'|} ``}",
			"    ${10:#-ButtonMiddleText '${11:Later}' ``}",
			"    ${12:#-Icon ${13|None,Information,Question,Exclamation,Warning,Error,Shield|} ``}",
			"    ${14:#-MessageAlignment ${15|Center,Left,Right|} ``}",
			"    ${16:#-WindowLocation ${17|Default,BottomLeft,BottomRight,TopLeft,TopRight|} ``}",
			"    ${18:#-Timeout ${19:600} ``}",
			"    ${20:#-NoWait ``}",
			"    ${21:#-PersistPrompt ``}",
			"    ${22:#-MinimizeWindows ``}",
			"    ${23:#-NoExitOnTimeout ``}",
			"    ${24:#-NotTopMost ``}",
			"    ${25:#-AllowMove ``}",
			"    ${26:#-Force}",
			"",
			"# Process result",
			"switch (\\$result) {",
			"    ${27:'OK'} { Write-ADTLogEntry 'User clicked OK' }",
			"    ${28:'Cancel'} { Write-ADTLogEntry 'User cancelled'; Exit-Script -ExitCode 1618 }",
			"    'Timeout' { Write-ADTLogEntry 'Dialog timed out' }",
			"}",
			"",
			"# Mit RequestInput (User-Eingabe)",
			"${29:#\\$userInput = Show-ADTInstallationPrompt -RequestInput -DefaultValue 'XXXX' -Message 'Enter your license key:' -ButtonRightText 'Submit'}",
			"${30:#Write-ADTLogEntry \"User entered: \\$userInput\"}$0"
		],
		"description": "PSADT: Show custom installation prompt with branding and buttons"
	},
	"Show-ADTInstallationRestartPrompt": {
		"prefix": "ShowInstallationRestartPrompt",
		"body": [
			"# Native: shutdown.exe /r /t 600 /c \"Restart required\" /d p:4:1",
			"<#",
			"  Verwendung: Restart-Prompt mit Countdown anzeigen (sofort oder mit Timer)",
			"  KRITISCH: Code NACH dieser Funktion wird möglicherweise NICHT ausgeführt wenn Restart erfolgt!",
			"  CountdownSeconds: Timer bis automatischer Restart (Standard: 60 Sekunden)",
			"  CountdownNoHideSeconds: Letzte X Sekunden kann Dialog NICHT minimiert werden (Standard: 30)",
			"  NoCountdown: Sofortiger Restart-Prompt ohne Timer",
			"  SilentRestart: Restart im Silent Mode (ohne User-Interaktion)",
			"  CustomText: Verwendet \\$adtStrings.RestartPrompt.CustomMessage aus strings.psd1",
			"  WindowLocation: Dialog-Position auf dem Bildschirm",
			"  NotTopMost: Dialog ist NICHT immer im Vordergrund (Standard: topmost)",
			"#>",
			"Show-ADTInstallationRestartPrompt `",
			"    ${1|#-NoCountdown ``,-NoCountdown ``|} `",
			"    ${2:-CountdownSeconds ${3:600} ``}",
			"    ${4:#-CountdownNoHideSeconds ${5:60} ``}",
			"    ${6:#-SilentRestart ``}",
			"    ${7:#-SilentCountdownSeconds ${8:5} ``}",
			"    ${9:#-WindowLocation ${10|Default,TopLeft,Top,TopRight,Left,Center,Right,BottomLeft,Bottom,BottomRight|} ``}",
			"    ${11:#-CustomText ``}",
			"    ${12:#-NotTopMost ``}",
			"    ${13:#-AllowMove}$0"
		],
		"description": "PSADT: Display restart prompt with countdown (Auto-restart after X seconds)"
	},
	"Show-ADTInstallationWelcome": {
		"prefix": "ShowInstallationWelcome",
		"body": [
			"# Native: Get-Process winword,excel | Stop-Process -Force (simplifiziert, ohne UI/Deferral)",
			"<#",
			"  Verwendung: Welcome-Dialog mit App-Close + Deferral-Optionen (Hauptfunktion für User-Interaktion!)",
			"  KRITISCH: Dialog timeout nach 55 Min (config.psd1) → Exit 1618 (SCCM Fast Retry)",
			"  SCENARIOS: Wähle Hauptszenario - CloseProcesses (Apps schließen), Silent (ohne Dialog), AllowDefer (nur Verschiebung), Basic (nur Info)",
			"  CloseProcesses: Apps die geschlossen werden müssen - @{Name='winword'}, @{Name='excel'; Description='Microsoft Excel'}",
			"  Silent: Schließt Apps OHNE Dialog (sofort, keine User-Interaktion)",
			"  AllowDefer: User kann Installation verschieben (DeferTimes/DeferDays/DeferDeadline)",
			"  AllowDeferCloseProcesses: Defer nur möglich wenn Apps laufen (aktiviert automatisch AllowDefer)",
			"  CloseProcessesCountdown: Auto-Close nach X Sekunden (nur wenn Deferral abgelaufen)",
			"  ForceCloseProcessesCountdown: Auto-Close nach X Sekunden (IMMER, auch mit Deferral)",
			"  ForceCountdown: Auto-Continue nach X Sekunden (wenn AllowDefer aktiv)",
			"  BlockExecution: Verhindert Start der Apps während Installation (via IFEO)",
			"  PromptToSave: Fragt User ob Dokumente gespeichert werden sollen (NICHT in SYSTEM context!)",
			"  PersistPrompt: Dialog bleibt zentriert und kehrt alle paar Sekunden zurück (nervt User)",
			"  CheckDiskSpace: Prüft verfügbaren Speicherplatz (auto-berechnet oder mit RequiredDiskSpace)",
			"  DeferRunInterval: Zeitspanne bis erneute Abfrage wenn App noch läuft - [TimeSpan]::FromHours(24)",
			"#>",
			"",
			"# SCENARIO: ${1|Basic (Info only),CloseProcesses (Apps schließen),Silent (Apps schließen ohne Dialog),AllowDefer (nur Verschiebung)|}",
			"Show-ADTInstallationWelcome `",
			"    ${2:-CloseProcesses @{Name='${3:winword}'}, @{Name='${4:excel}'} ``}",
			"    ${5:#-Silent ``}",
			"    ${6:#-AllowDefer ``}",
			"    ${7:#-AllowDeferCloseProcesses ``}",
			"    ${8:#-DeferTimes ${9:3} ``}",
			"    ${10:#-DeferDays ${11:7} ``}",
			"    ${12:#-DeferDeadline '${13:2026-12-31}' ``}",
			"    ${14:#-DeferRunInterval ([System.TimeSpan]::FromHours(${15:24})) ``}",
			"    ${16:#-CloseProcessesCountdown ${17:600} ``}",
			"    ${18:#-ForceCloseProcessesCountdown ${19:300} ``}",
			"    ${20:#-ForceCountdown ${21:120} ``}",
			"    ${22:#-BlockExecution ``}",
			"    ${23:#-PromptToSave ``}",
			"    ${24:#-PersistPrompt ``}",
			"    ${25:#-HideCloseButton ``}",
			"    ${26:#-MinimizeWindows ``}",
			"    ${27:#-CheckDiskSpace ``}",
			"    ${28:#-RequiredDiskSpace ${29:500} ``}",
			"    ${30:#-WindowLocation ${31|Default,TopLeft,Top,TopRight,Left,Center,Right,BottomLeft,Bottom,BottomRight|} ``}",
			"    ${32:#-CustomText ``}",
			"    ${33:#-NotTopMost ``}",
			"    ${34:#-AllowMove}",
			"",
			"# CloseProcesses Beispiel: Show-ADTInstallationWelcome -CloseProcesses @{Name='winword'}, @{Name='excel'} -CloseProcessesCountdown 600",
			"# Silent Beispiel: Show-ADTInstallationWelcome -CloseProcesses @{Name='winword'}, @{Name='excel'} -Silent",
			"# AllowDefer Beispiel: Show-ADTInstallationWelcome -AllowDefer -DeferTimes 5 -DeferDeadline '2026-12-31'",
			"# Combined: Show-ADTInstallationWelcome -CloseProcesses @{Name='winword'}, @{Name='excel'} -AllowDefer -DeferTimes 10 -CloseProcessesCountdown 600 -BlockExecution$0"
		],
		"description": "PSADT: Show welcome dialog with app close + deferral options (Main user interaction!)"
	},
	"Start-ADTMsiProcess": {
		"prefix": "StartMsiProcess",
		"body": [
			"# Native: msiexec.exe /i \"file.msi\" /qn /l*v \"C:\\\\Logs\\\\install.log\" PROPERTY=VALUE",
			"<#",
			"  Verwendung: MSI Install/Uninstall/Patch/Repair mit automatischem Logging",
			"  KRITISCH: Bei Action=Install wird übersprungen wenn MSI bereits installiert ist!",
			"  FilePath: Pfad zur MSI/MSP-Datei (wenn nur Filename → sucht in \\$adtSession.DirFiles)",
			"  ProductCode: Für Uninstall via GUID - {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}",
			"  Action: Install (Standard), Uninstall, Patch, Repair, ActiveSetup",
			"  Transforms: MST-Dateien (im selben Ordner wie MSI) - 'transform.mst' oder mehrere: 'app.mst','custom.mst'",
			"  Patches: MSP-Dateien für Install Action (im selben Ordner wie MSI)",
			"  ArgumentList: Überschreibt Standard-Parameter aus config.psd1 (komplett ersetzen!)",
			"  AdditionalArgumentList: Fügt Parameter HINZU (empfohlen!) - Array: 'ALLUSERS=1','PROPERTY=VALUE'",
			"  SecureArgumentList: Versteckt Parameter im Log (für Lizenzen/Passwörter)",
			"  LogFileName: Custom Log-Name (Standard: auto-generiert aus MSI-Name)",
			"  RepairMode: 'Repair' (msiexec /f - kann Reboot erzwingen!) oder 'Reinstall' (REINSTALL=ALL)",
			"  SkipMSIAlreadyInstalledCheck: Installiert auch wenn MSI bereits vorhanden",
			"  PassThru: Gibt ExitCode/StdOut/StdErr zurück (für \\$result = Start-ADTMsiProcess ...)",
			"  NoWait: Startet Prozess und wartet NICHT auf Completion",
			"  ExitOnProcessFailure: Beendet Deployment bei Fehler (via Close-ADTSession)",
			"#>",
			"Start-ADTMsiProcess `",
			"    -Action ${1|Install,Uninstall,Patch,Repair,ActiveSetup|} `",
			"    ${2|-FilePath '${3:Adobe_Reader.msi}',-ProductCode '{${4:XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}}'|} `",
			"    ${5:#-Transforms '${6:transform.mst}' ``}",
			"    ${7:#-Patches '${8:patch.msp}' ``}",
			"    ${9:-AdditionalArgumentList 'ALLUSERS=1', '${10:PROPERTY=VALUE}' ``}",
			"    ${12:#-ArgumentList '/qn', '/norestart' ``}",
			"    ${13:#-SecureArgumentList ``}",
			"    ${14:#-LogFileName '${15:CustomInstall.log}' ``}",
			"    ${16:#-WorkingDirectory '${17:\\$adtSession.DirFiles}' ``}",
			"    ${18:#-RepairMode ${19|Repair,Reinstall|} ``}",
			"    ${20:#-RepairFromSource ``}",
			"    ${21:#-SkipMSIAlreadyInstalledCheck ``}",
			"    ${22:#-SuccessExitCodes 0, 3010 ``}",
			"    ${23:#-RebootExitCodes 1641, 3010 ``}",
			"    ${24:#-IgnoreExitCodes 1619 ``}",
			"    ${25:-PassThru ``}",
			"    ${26:#-NoWait ``}",
			"    ${27:#-ExitOnProcessFailure ``}",
			"    ${28:#-NoDesktopRefresh}",
			"",
			"# Beispiele:",
			"${29:#Start-ADTMsiProcess -Action Install -FilePath 'App.msi' -Transforms 'custom.mst' -AdditionalArgumentList 'ALLUSERS=1'}",
			"${30:#Start-ADTMsiProcess -Action Uninstall -ProductCode '{26923b43-4d38-484f-9b9e-de460746276c}'}",
			"${31:#\\$msiResult = Start-ADTMsiProcess -Action Install -FilePath 'Setup.msi' -PassThru; if (\\$msiResult.ExitCode -eq 0) { Write-ADTLogEntry 'Success' \\}}$0"
		],
		"description": "PSADT: Execute MSI installer with auto-logging (Install/Uninstall/Patch/Repair)"
	},
	"Start-ADTMsiProcessAsUser": {
		"prefix": "StartMsiProcessAsUser",
		"body": [
			"# Native: runas /user:DOMAIN\\\\User \"msiexec.exe /i file.msi /qn\" (simplifiziert)",
			"<#",
			"  Verwendung: MSI im User-Context ausführen (nicht als SYSTEM)",
			"  KRITISCH: Username-Parameter nur erforderlich wenn nicht bereits \\$RunAsActiveUser definiert!",
			"  Identisch zu Start-ADTMsiProcess, aber läuft als User statt SYSTEM",
			"  Username: NTAccount - 'DOMAIN\\\\User' (Standard: \\$RunAsActiveUser.UserName)",
			"  UseLinkedAdminToken: Verwendet Admin-Token des Users (falls vorhanden)",
			"  UseHighestAvailableToken: Verwendet höchsten verfügbaren Token (Admin falls vorhanden)",
			"  InheritEnvironmentVariables: User-Prozess erbt SYSTEM Environment Variables",
			"  DenyUserTermination: User kann Prozess NICHT beenden (außer als Admin)",
			"  Alle anderen Parameter wie Start-ADTMsiProcess!",
			"#>",
			"Start-ADTMsiProcessAsUser `",
			"    ${1:#-Username '${2:DOMAIN\\\\User}' ``}",
			"    -Action ${3|Install,Uninstall,Patch,Repair,ActiveSetup|} `",
			"    ${4|-FilePath '${5:Adobe_Reader.msi}',-ProductCode '{${6:XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}}'|} `",
			"    ${7:#-Transforms '${8:transform.mst}' ``}",
			"    ${10:-AdditionalArgumentList 'ALLUSERS=2', '${11:PROPERTY=VALUE}' ``}",
			"    ${12:#-UseLinkedAdminToken ``}",
			"    ${13:#-UseHighestAvailableToken ``}",
			"    ${14:#-InheritEnvironmentVariables ``}",
			"    ${15:#-DenyUserTermination ``}",
			"    ${16:#-LogFileName '${17:UserContextInstall.log}' ``}",
			"    ${18:#-PassThru ``}",
			"    ${19:#-NoWait}",
			"",
			"# Beispiele:",
			"${20:#Start-ADTMsiProcessAsUser -Action Install -FilePath 'UserApp.msi' -AdditionalArgumentList 'ALLUSERS=2'}",
			"${21:#\\$userMsiResult = Start-ADTMsiProcessAsUser -Username 'DOMAIN\\\\JohnDoe' -Action Install -FilePath 'Setup.msi' -UseHighestAvailableToken -PassThru}$0"
		],
		"description": "PSADT: Execute MSI in user context (not as SYSTEM)"
	},
	"Start-ADTMspProcess": {
		"prefix": "StartMspProcess",
		"body": [
			"# Native: msiexec.exe /p \"patch.msp\" /qn /l*v \"C:\\\\Logs\\\\patch.log\"",
			"<#",
			"  Verwendung: MSP Patch-Datei installieren (prüft automatisch betroffene Produkte)",
			"  KRITISCH: Liest SummaryInfo aus MSP und prüft welche installierten Produkte betroffen sind!",
			"  Wenn kein passendes Produkt installiert → Terminiert ohne Fehler",
			"  FilePath: Pfad zur MSP-Datei (Patch-File für MSI-Produkte)",
			"  AdditionalArgumentList: Zusätzliche MSI-Parameter - Array: 'PROPERTY=VALUE'",
			"  SecureArgumentList: Versteckt Parameter im Log",
			"  Verwendet automatisch config.psd1 MSI-Standardparameter",
			"  LogFileName: Custom Log-Name (Standard: auto-generiert)",
			"  PassThru: Gibt ExitCode/StdOut/StdErr zurück",
			"  NoWait: Startet Patch und wartet NICHT auf Completion",
			"#>",
			"Start-ADTMspProcess `",
			"    -FilePath '${1:Adobe_Reader_Patch.msp}' `",
			"    ${2:-AdditionalArgumentList 'REINSTALL=ALL', '${3:PROPERTY=VALUE}' ``}",
			"    ${4:#-SecureArgumentList ``}",
			"    ${6:#-LogFileName '${7:PatchInstall.log}' ``}",
			"    ${8:#-SuccessExitCodes 0, 3010 ``}",
			"    ${9:#-RebootExitCodes 1641, 3010 ``}",
			"    ${10:#-PassThru ``}",
			"    ${11:#-NoWait ``}",
			"    ${12:#-ExitOnProcessFailure ``}",
			"    ${13:#-NoDesktopRefresh}",
			"",
			"# Beispiele:",
			"${14:#Start-ADTMspProcess -FilePath 'AcroRdr2017Upd1701130143_MUI.msp'}",
			"${15:#Start-ADTMspProcess -FilePath 'Office_Patch.msp' -AdditionalArgumentList 'ALLUSERS=1'}",
			"${16:#\\$patchResult = Start-ADTMspProcess -FilePath 'Update.msp' -PassThru; if (\\$patchResult.ExitCode -eq 0) { Write-ADTLogEntry 'Patch applied successfully' \\}}$0"
		],
		"description": "PSADT: Execute MSP patch file (Auto-detects applicable products)"
	},


	"Start-ADTMspProcessAsUser": {
		"prefix": "startmspprocessasuser",
		"body": [
			"# Native: msiexec.exe /p \\\"file.msp\\\" /qn PROPERTY=VALUE (manuell als User ausführen)",
			"<#",
			"  Verwendung: Führt MSP-Patch als angemeldeter User aus (nicht als SYSTEM)",
			"  KRITISCH: Benötigt aktiven User! Bei SYSTEM-Account wird automatisch nach eingeloggtem User gesucht",
			"  Nutzt gleiche Logik wie Start-ADTMsiProcess (SummaryInfo, ProductCode-Prüfung, Logging)",
			"  FilePath: REQUIRED - Pfad zur MSP-Datei (z.B. \\\"\\$adtSession.DirFiles\\\\Adobe_Reader_11.0.3_EN.msp\\\")",
			"  AdditionalArgumentList: MSI Properties (z.B. 'ALLUSERS=1 REBOOT=ReallySuppress')",
			"  UseLinkedAdminToken: Nutzt Admin-Token des Users (UAC Bypass für installierte Apps)",
			"  PassThru: Gibt ProcessResult zurück (ExitCode, StdOut, StdErr)",
			"#>",
			"Start-ADTMspProcessAsUser ``",
			"    -FilePath \\\"${1:\\$adtSession.DirFiles\\\\update.msp}\\\" ``",
			"    -AdditionalArgumentList '${2:ALLUSERS=1 REBOOT=ReallySuppress}' ``",
			"    ${3|#-Username \\$RunAsActiveUser.UserName ``,-Username \\$RunAsActiveUser.UserName ``|}",
			"    ${4|#-UseLinkedAdminToken ``,-UseLinkedAdminToken ``|}",
			"    ${5|#-UseHighestAvailableToken ``,-UseHighestAvailableToken ``|}",
			"    ${6|#-InheritEnvironmentVariables ``,-InheritEnvironmentVariables ``|}",
			"    ${7|#-DenyUserTermination ``,-DenyUserTermination ``|}",
			"    ${8|#-PassThru,-PassThru|}$0"
		],
		"description": "Führt MSP-Patch als angemeldeter User aus (nutzt Start-ADTMsiProcess Logik)"
	},
	"Start-ADTProcess": {
		"prefix": "startprocess",
		"body": [
			"# Native: Start-Process -FilePath 'setup.exe' -ArgumentList '/S' -Wait -PassThru -WindowStyle Hidden",
			"<#",
			"  Verwendung: Führt EXE/CMD/BAT mit erweiterten Optionen aus (wichtigste PSADT-Funktion!)",
			"  KRITISCH: Default WorkingDirectory = \\$adtSession.DirFiles (wenn aktive Session existiert)",
			"  FilePath: REQUIRED - Dateiname (setup.exe) ODER voller Pfad (C:\\\\Temp\\\\setup.exe)",
			"  ArgumentList: String-Array empfohlen! Vermeidet Escaping-Probleme: @('/S', '/V\\\"/qn\\\"')",
			"  WindowStyle: Normal, Hidden, Maximized, Minimized (Empfehlung wird an Prozess übergeben)",
			"  SuccessExitCodes: Standard 0, bei Setup.exe oft auch 1,2 oder 3010 (Reboot)",
			"  PassThru: Gibt ProcessResult zurück mit ExitCode, StdOut, StdErr, Interleaved",
			"  WaitForMsiExec: Bei EXE-Bootstrappern die MSI starten (wartet auf freien msiexec)",
			"#>",
			"Start-ADTProcess ``",
			"    -FilePath \\\"${1:setup.exe}\\\" ``",
			"    -ArgumentList ${2|'/S',@('/S', '/v\\\"/qn\\\"'),'--silent --accept-license'|} ``",
			"    ${3|#-WorkingDirectory \\\"\\$\\(\\$adtSession.DirFiles\\)\\\" ``,-WorkingDirectory \\\"\\$\\(\\$adtSession.DirFiles\\)\\\" ``|}",
			"    ${4|#-WindowStyle Hidden ``,-WindowStyle Hidden ``|}",
			"    ${5|#-CreateNoWindow ``,-CreateNoWindow ``|}",
			"    ${6|#-SuccessExitCodes 0,1,2,3010 ``,-SuccessExitCodes 0,1,2,3010 ``|}",
			"    ${7|#-WaitForMsiExec ``,-WaitForMsiExec ``|}",
			"    ${8|#-PassThru,-PassThru|}$0"
		],
		"description": "Führt Prozess mit erweiterten Optionen aus (EXE/CMD/BAT)"
	},
	"Start-ADTProcessAsUser": {
		"prefix": "startprocessasuser",
		"body": [
			"# Native: Keine - erfordert komplexe Token-Manipulation mit CreateProcessAsUser Win32 API",
			"<#",
			"  Verwendung: Führt Prozess im Context eines angemeldeten Users aus (von SYSTEM)",
			"  KRITISCH: Nur von SYSTEM-Account nutzbar! Bei User-Context nutze Start-ADTProcess",
			"  FilePath: REQUIRED - EXE/CMD/BAT (z.B. \\\"notepad.exe\\\" oder \\\"\\$adtSession.DirFiles\\\\usersetup.exe\\\")",
			"  Username: Optional - Standard = aktiv angemeldeter User (\\$RunAsActiveUser)",
			"  UseLinkedAdminToken: Nutzt erhöhten Admin-Token falls verfügbar (UAC Bypass)",
			"  UseHighestAvailableToken: Nutzt höchsten Token (Admin falls vorhanden, sonst User)",
			"  InheritEnvironmentVariables: User-Prozess erbt SYSTEM Environment Vars",
			"  DenyUserTermination: User kann Prozess NICHT beenden (außer als Admin)",
			"  PassThru: Gibt ProcessResult zurück (ExitCode, StdOut, StdErr)",
			"#>",
			"Start-ADTProcessAsUser ``",
			"    -FilePath \\\"${1:notepad.exe}\\\" ``",
			"    -ArgumentList ${2|'C:\\\\readme.txt','--user-mode'|} ``",
			"    ${3|#-Username \\$RunAsActiveUser.UserName ``,-Username \\$RunAsActiveUser.UserName ``|}",
			"    ${4|#-UseLinkedAdminToken ``,-UseLinkedAdminToken ``|}",
			"    ${5|#-UseHighestAvailableToken ``,-UseHighestAvailableToken ``|}",
			"    ${6|#-InheritEnvironmentVariables ``,-InheritEnvironmentVariables ``|}",
			"    ${7|#-WindowStyle Hidden ``,-WindowStyle Hidden ``|}",
			"    ${8|#-CreateNoWindow ``,-CreateNoWindow ``|}",
			"    ${9|#-DenyUserTermination ``,-DenyUserTermination ``|}",
			"    ${10|#-PassThru,-PassThru|}$0"
		],
		"description": "Führt Prozess als angemeldeter User aus (von SYSTEM)"
	},
	"Start-ADTServiceAndDependencies": {
		"prefix": "startserviceanddependencies",
		"body": [
			"# Native: Start-Service -Name 'wuauserv' (behandelt Dependencies NICHT automatisch!)",
			"<#",
			"  Verwendung: Startet Windows-Service UND alle abhängigen Services automatisch",
			"  KRITISCH: Standard PowerShell Start-Service startet NUR den Service, NICHT die Dependencies!",
			"  Name: REQUIRED - Service-Name (z.B. 'wuauserv' für Windows Update)",
			"  SkipDependentServices: Startet NUR den Service, ignoriert Dependencies",
			"  PendingStatusWait: Wartezeit falls Service in Pending-State (Default: 60 Sekunden)",
			"  PassThru: Gibt ServiceController-Objekt zurück",
			"  Prüft automatisch ob Service bereits läuft (überspringt dann)",
			"  Verwendet net start bei PowerShell < 6 für bessere Kompatibilität",
			"#>",
			"Start-ADTServiceAndDependencies ``",
			"    -Name '${1:wuauserv}' ``",
			"    ${2|#-SkipDependentServices ``,-SkipDependentServices ``|}",
			"    ${3|#-PendingStatusWait \\(New-TimeSpan -Seconds 60\\) ``,-PendingStatusWait \\(New-TimeSpan -Seconds 120\\) ``|}",
			"    ${4|#-PassThru,-PassThru|}$0"
		],
		"description": "Startet Windows-Service inkl. aller Dependencies"
	},
	"Stop-ADTServiceAndDependencies": {
		"prefix": "stopserviceanddependencies",
		"body": [
			"# Native: Stop-Service -Name 'wuauserv' -Force (behandelt Dependencies NICHT automatisch!)",
			"<#",
			"  Verwendung: Stoppt Windows-Service UND alle abhängigen Services automatisch",
			"  KRITISCH: Standard PowerShell Stop-Service stoppt NUR den Service, NICHT die Dependencies!",
			"  Name: REQUIRED - Service-Name (z.B. 'wuauserv' für Windows Update)",
			"  SkipDependentServices: Stoppt NUR den Service, ignoriert Dependencies",
			"  PendingStatusWait: Wartezeit falls Service in Pending-State (Default: 60 Sekunden)",
			"  PassThru: Gibt ServiceController-Objekt zurück",
			"  Prüft automatisch ob Service bereits gestoppt ist (überspringt dann)",
			"  Verwendet net stop bei PowerShell < 6 für bessere Kompatibilität",
			"#>",
			"Stop-ADTServiceAndDependencies ``",
			"    -Name '${1:wuauserv}' ``",
			"    ${2|#-SkipDependentServices ``,-SkipDependentServices ``|}",
			"    ${3|#-PendingStatusWait \\(New-TimeSpan -Seconds 60\\) ``,-PendingStatusWait \\(New-TimeSpan -Seconds 120\\) ``|}",
			"    ${4|#-PassThru,-PassThru|}$0"
		],
		"description": "Stoppt Windows-Service inkl. aller Dependencies"
	},
	"Test-ADTBattery": {
		"prefix": "testbattery",
		"body": [
			"# Native: (Get-CimInstance Win32_Battery).BatteryStatus -eq 2 (true = AC Power)",
			"<#",
			"  Verwendung: Prüft ob Gerät am Stromnetz oder auf Batterie läuft",
			"  KRITISCH: Desktop-PCs geben immer \\$true zurück (AC Power erkannt)",
			"  Ohne -PassThru: Boolean (\\$true = AC Power, \\$false = Batterie)",
			"  Mit -PassThru: BatteryInfo-Objekt mit allen Details",
			"  Properties (mit -PassThru):",
			"    IsUsingACPower      - \\$true wenn am Stromnetz",
			"    IsLaptop            - \\$true wenn Laptop/Notebook erkannt",
			"    BatteryLifePercent  - Ladung in Prozent (0-100)",
			"    ACPowerLineStatus   - Online, Offline, Unknown",
			"    BatteryChargeStatus - High, Low, Critical, Charging, etc.",
			"  Nutzung: Installation verhindern wenn Batterie < 20% und kein AC",
			"#>",
			"${1|\\$isOnACPower,\\$batteryInfo|} = Test-ADTBattery ${2|,-PassThru|}",
			"",
			"# Beispiel: Installation nur bei AC Power erlauben",
			"# if (-not \\$isOnACPower) {",
			"#     Show-ADTInstallationPrompt -Message 'Bitte Netzteil anschließen!' -ButtonRightText 'OK' -Icon Warning",
			"#     Close-ADTSession -ExitCode 1618",
			"# }",
			"",
			"# Beispiel: Batterie-Status mit -PassThru prüfen",
			"# if (\\$batteryInfo.IsLaptop -and \\$batteryInfo.BatteryLifePercent -lt 20 -and -not \\$batteryInfo.IsUsingACPower) {",
			"#     Write-ADTLogEntry -Message \\\"Batterie zu niedrig: \\$\\(\\$batteryInfo.BatteryLifePercent\\)%\\\" -Severity 2",
			"# }$0"
		],
		"description": "Prüft AC Power vs. Batterie (mit -PassThru alle Details)"
	},
	"Test-ADTCallerIsAdmin": {
		"prefix": "testcallerisadmin",
		"body": [
			"# Native: ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)",
			"<#",
			"  Verwendung: Prüft ob aktueller Benutzer Administrator-Rechte hat",
			"  KRITISCH: Prüft NICHT ob Prozess elevated ist, sondern ob User in Administrators-Gruppe!",
			"  Gibt \\$true zurück wenn User Admin-Rechte hat (auch wenn UAC noch nicht erhöht)",
			"  Gibt \\$false zurück bei Standard-User ohne Admin-Rechte",
			"  ACHTUNG: Bei UAC gibt Funktion \\$true zurück auch wenn Prozess nicht elevated!",
			"  Für Elevated-Prüfung nutze: ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator) -and (New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)",
			"  Nutzung: Installation nur für Admins erlauben, Features für Power-User freischalten",
			"#>",
			"${1:\\$isAdmin} = Test-ADTCallerIsAdmin",
			"",
			"# Beispiel: Installation nur für Admins erlauben",
			"# if (-not \\$isAdmin) {",
			"#     Show-ADTInstallationPrompt -Message 'Installation erfordert Administrator-Rechte!' -ButtonRightText 'OK' -Icon Stop",
			"#     Close-ADTSession -ExitCode 1603",
			"# }$0"
		],
		"description": "Prüft ob aktueller User Admin-Rechte hat"
	},
	"Test-ADTEspActive": {
		"prefix": "testespactive",
		"body": [
			"# Native: Komplex - Registry (HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Enrollments\\\\*\\\\FirstSync\\\\SID) + wwahost.exe Prozess-Prüfung",
			"<#",
			"  Verwendung: Prüft ob Gerät in Enrollment Status Page (ESP) Phase ist (Autopilot/Intune)",
			"  KRITISCH: Nur relevant für Windows Autopilot und Intune-Deployments!",
			"  ESP = Enrollment Status Page (zeigt Fortschritt bei neuem Gerät/User-Setup)",
			"  Gibt \\$true zurück wenn:",
			"    - wwahost.exe (ESP UI) läuft UND",
			"    - OOBE nicht abgeschlossen ODER",
			"    - User ESP noch aktiv (IsSyncDone = \\$false in Registry)",
			"  Gibt \\$false zurück bei:",
			"    - Desktop-Betrieb (kein ESP)",
			"    - ESP bereits abgeschlossen",
			"  Nutzung: Installation während ESP verzögern/überspringen (Konflikte vermeiden)",
			"#>",
			"${1:\\$isEspActive} = Test-ADTEspActive",
			"",
			"# Beispiel: Installation während ESP überspringen",
			"# if (\\$isEspActive) {",
			"#     Write-ADTLogEntry -Message 'ESP aktiv - Installation wird übersprungen' -Severity 2",
			"#     Close-ADTSession -ExitCode 0",
			"# }$0"
		],
		"description": "Prüft ob Gerät in ESP-Phase ist (Autopilot/Intune)"
	},
	"Test-ADTMicrophoneInUse": {
		"prefix": "testmicrophoneinuse",
		"body": [
			"# Native: Keine - erfordert P/Invoke zu Windows Audio Session API (IAudioSessionManager2)",
			"<#",
			"  Verwendung: Prüft ob Mikrofon aktiv genutzt wird (Teams, Zoom, Gaming, Recording)",
			"  KRITISCH: Erkennt JEDE Mikrofon-Nutzung (nicht nur Teams/Zoom!)",
			"  Gibt \\$true zurück wenn Mikrofon aktiv ist (Audio-Stream läuft)",
			"  Gibt \\$false zurück wenn kein Mikrofon-Zugriff",
			"  Nutzung: Installation während Meeting/Aufnahme vermeiden",
			"  Technologie: Windows Audio Session API über C# P/Invoke",
			"  ACHTUNG: Prüft NUR Mikrofon, NICHT ob User in Meeting ist!",
			"#>",
			"${1:\\$isMicInUse} = Test-ADTMicrophoneInUse",
			"",
			"# Beispiel: Installation während Mikrofon-Nutzung verzögern",
			"# if (\\$isMicInUse) {",
			"#     Write-ADTLogEntry -Message 'Mikrofon in Verwendung - warte 5 Minuten' -Severity 2",
			"#     Start-Sleep -Seconds 300",
			"# }$0"
		],
		"description": "Prüft ob Mikrofon aktiv genutzt wird (Teams/Zoom/etc.)"
	},
	"Test-ADTModuleInitialized": {
		"prefix": "testmoduleinitialized",
		"body": [
			"# Native: Get-Module -Name PSAppDeployToolkit (prüft ob geladen, NICHT ob initialisiert!)",
			"<#",
			"  Verwendung: Prüft ob PSADT-Modul vollständig initialisiert ist",
			"  KRITISCH: Unterschied zu Get-Module - prüft Initialize-ADTModule Status!",
			"  Gibt \\$true zurück wenn Initialize-ADTModule erfolgreich ausgeführt wurde",
			"  Gibt \\$false zurück wenn Modul nur geladen aber nicht initialisiert",
			"  Initialize-ADTModule lädt:",
			"    - Config.psd1",
			"    - Strings.psd1 (Sprache)",
			"    - Environment-Variablen (\\$envWinDir, \\$envProgramFiles, etc.)",
			"    - Command Table",
			"  Nutzung: Vor eigenen PSADT-Erweiterungen prüfen ob Modul bereit ist",
			"#>",
			"${1:\\$isInitialized} = Test-ADTModuleInitialized",
			"",
			"# Beispiel: Vor Nutzung prüfen",
			"# if (-not \\$isInitialized) {",
			"#     Initialize-ADTModule",
			"# }$0"
		],
		"description": "Prüft ob PSADT-Modul vollständig initialisiert ist"
	},
	"Test-ADTMSUpdates": {
		"prefix": "testmsupdates",
		"body": [
			"# Native: Get-HotFix -Id KB2549864 (funktioniert nicht immer - limitiert)",
			"<#",
			"  Verwendung: Prüft ob Windows Update installiert ist (KB-Nummer)",
			"  KRITISCH: Nutzt ZWEI Methoden - Get-HotFix (schnell) UND COM Object (langsam aber genau)",
			"  KbNumber: REQUIRED - KB-Nummer (z.B. 'KB2549864', 'KB5034441')",
			"  Get-HotFix funktioniert NICHT für:",
			"    - Feature Updates (z.B. Win11 22H2 → 23H2)",
			"    - Optionale Updates",
			"    - Treiber-Updates über Windows Update",
			"  Bei Get-HotFix Fehler: Nutzt Microsoft.Update.Session COM Object (Windows Update History)",
			"  COM Object prüft: Operation = Install (1) UND ResultCode = Success (2)",
			"  Nutzung: Prerequisite-Check (\\\"Installation erfordert KB5034441\\\")",
			"#>",
			"${1:\\$isInstalled} = Test-ADTMSUpdates -KbNumber '${2:KB2549864}'",
			"",
			"# Beispiel: Installation abbrechen wenn Update fehlt",
			"# if (-not \\$isInstalled) {",
			"#     Show-ADTInstallationPrompt -Message 'Bitte zuerst KB5034441 installieren!' -ButtonRightText 'OK' -Icon Warning",
			"#     Close-ADTSession -ExitCode 1603",
			"# }$0"
		],
		"description": "Prüft ob Windows Update installiert ist (KB-Nummer)"
	},
	"Test-ADTMutexAvailability": {
		"prefix": "testmutexavailability",
		"body": [
			"# Native: [System.Threading.Mutex]::OpenExisting('Global\\\\_MSIExecute').WaitOne(1000)",
			"<#",
			"  Verwendung: Prüft ob Mutex verfügbar ist (z.B. ob msiexec.exe frei ist)",
			"  KRITISCH: Standard-Check für MSI installations - verhindert parallele MSI-Installationen!",
			"  MutexName: REQUIRED - Mutex-Name (z.B. 'Global\\\\_MSIExecute' für msiexec.exe)",
			"  MutexWaitTime: Wartezeit in Millisekunden (Default: 1ms = sofort prüfen, kein warten)",
			"    - 0 = Nur Status prüfen, nicht warten",
			"    - 1 = 1 Millisekunde (schneller Check)",
			"    - 5000 = 5 Sekunden warten",
			"    - -1 = Unbegrenzt warten (VORSICHT: Deadlock-Gefahr!)",
			"  Gibt \\$true wenn Mutex frei ist (Lock erfolgreich)",
			"  Gibt \\$false wenn Mutex belegt ist (anderer Prozess nutzt ihn)",
			"  Bei Global\\\\_MSIExecute: Zeigt laufende MSI-Installation in Log",
			"  Nutzung: Vor MSI-Installation prüfen ob msiexec.exe frei ist",
			"#>",
			"${1:\\$isMsiExecFree} = Test-ADTMutexAvailability ``",
			"    -MutexName '${2:Global\\\\_MSIExecute}' ``",
			"    -MutexWaitTime ${3|(New-TimeSpan -Milliseconds 1),(New-TimeSpan -Seconds 30),(New-TimeSpan -Minutes 5)|}",
			"",
			"# Beispiel: Warten bis msiexec.exe frei ist (max 5 Minuten)",
			"# while (-not (Test-ADTMutexAvailability -MutexName 'Global\\\\_MSIExecute' -MutexWaitTime (New-TimeSpan -Seconds 10))) {",
			"#     Write-ADTLogEntry -Message 'MSI engine belegt - warte 10 Sekunden...'",
			"#     Start-Sleep -Seconds 10",
			"# }$0"
		],
		"description": "Prüft ob Mutex verfügbar ist (z.B. msiexec.exe frei)"
	},
	"Test-ADTNetworkConnection": {
		"prefix": "testnetworkconnection",
		"body": [
			"# Native: (Get-NetAdapter -Physical | Where-Object Status -eq 'Up').InterfaceType -contains 6 (Ethernet)",
			"<#",
			"  Verwendung: Prüft ob Netzwerkverbindung aktiv ist (Ethernet/Wi-Fi/andere)",
			"  KRITISCH: Prüft NUR lokale Adapter-Status, NICHT Internet-Konnektivität!",
			"  InterfaceType: Optional - Standard = Ethernet + Wireless80211 (Wi-Fi)",
			"  Verfügbare Typen:",
			"    - Ethernet (6) - Kabelgebundenes Netzwerk",
			"    - Wireless80211 (71) - Wi-Fi",
			"    - Ppp (23) - VPN über Modem",
			"    - Tunnel (131) - VPN Tunnel",
			"    - Wwanpp (243) - Mobile Broadband (LTE/5G)",
			"  Gibt \\$true wenn mindestens EIN Adapter vom gewünschten Typ 'Up' ist",
			"  Gibt \\$false wenn KEIN Adapter vom gewünschten Typ 'Up' ist",
			"  Nutzt Get-NetAdapter (PowerShell 3.0+, nur physische Adapter)",
			"  Nutzung: Installation nur bei aktivem Netzwerk erlauben",
			"#>",
			"${1:\\$hasNetwork} = Test-ADTNetworkConnection ${2|,-InterfaceType Ethernet,-InterfaceType Wireless80211,-InterfaceType @(6,71)|}",
			"",
			"# Beispiel: Installation nur bei Ethernet (kabelgebunden) erlauben",
			"# if (-not (Test-ADTNetworkConnection -InterfaceType Ethernet)) {",
			"#     Show-ADTInstallationPrompt -Message 'Bitte Netzwerkkabel anschließen!' -ButtonRightText 'OK' -Icon Warning",
			"#     Close-ADTSession -ExitCode 1618",
			"# }$0"
		],
		"description": "Prüft ob Netzwerkverbindung aktiv ist (Ethernet/Wi-Fi)"
	},
	"Test-ADTOobeCompleted": {
		"prefix": "testoobecompleted",
		"body": [
			"# Native: Komplex - C# P/Invoke zu OOBEComplete API (nicht verfügbar in PowerShell)",
			"<#",
			"  Verwendung: Prüft ob Windows OOBE (Out-of-Box Experience) abgeschlossen ist",
			"  KRITISCH: Nur relevant für neue Windows-Installationen oder Sysprep!",
			"  OOBE = Ersteinrichtung bei neuem PC:",
			"    - Sprachauswahl",
			"    - Lizenzvereinbarung",
			"    - Benutzer anlegen",
			"    - Netzwerk konfigurieren",
			"    - Privacy-Einstellungen",
			"  Gibt \\$true wenn OOBE abgeschlossen (normaler Desktop-Betrieb)",
			"  Gibt \\$false wenn OOBE läuft (Setup noch nicht fertig)",
			"  Nutzt Windows API ([PSADT.DeviceManagement.DeviceUtilities]::IsOOBEComplete())",
			"  Sysprep: Nach Sysprep /oobe ist OOBE wieder aktiv",
			"  Nutzung: Installation während OOBE überspringen (verhindert Konflikte)",
			"#>",
			"${1:\\$oobeComplete} = Test-ADTOobeCompleted",
			"",
			"# Beispiel: Installation während OOBE überspringen",
			"# if (-not \\$oobeComplete) {",
			"#     Write-ADTLogEntry -Message 'OOBE läuft - Installation wird übersprungen' -Severity 2",
			"#     Close-ADTSession -ExitCode 0",
			"# }$0"
		],
		"description": "Prüft ob Windows OOBE abgeschlossen ist"
	},
	"Test-ADTPowerPoint": {
		"prefix": "testpowerpoint",
		"body": [
			"# Native: Get-Process POWERPNT | Get-ADTWindowTitle -WindowTitle '^PowerPoint(-| Slide Show)'",
			"<#",
			"  Verwendung: Prüft ob PowerPoint in Präsentationsmodus läuft (Vollbild/Presenter)",
			"  KRITISCH: Erkennt NUR aktive Präsentationen, NICHT nur offene PowerPoint-Fenster!",
			"  Prüft DREI Dinge:",
			"    1. POWERPNT.exe Prozess läuft",
			"    2. Fenster-Titel beginnt mit \\\"PowerPoint Slide Show\\\" oder \\\"PowerPoint-\\\" (non-English)",
			"    3. Windows Presentation Mode aktiv (Get-ADTUserNotificationState)",
			"  Gibt \\$true wenn PowerPoint präsentiert (Fullscreen Slideshow ODER Presenter Mode)",
			"  Gibt \\$false wenn PowerPoint nur offen ist (Bearbeitungsmodus)",
			"  ACHTUNG: False Positive möglich wenn PowerPoint-Datei mit \\\"PowerPoint Slide Show\\\" beginnt!",
			"  Benötigt angemeldeten User (überspringt Check bei SYSTEM ohne User)",
			"  Vista+ Feature: Erkennt Presentation Mode auch ohne Vollbild-Fenster",
			"  Nutzung: Installation während Präsentation verzögern",
			"#>",
			"${1:\\$isPresenting} = Test-ADTPowerPoint",
			"",
			"# Beispiel: Installation während Präsentation verzögern (2 Stunden max)",
			"# \\$maxWaitTime = (Get-Date).AddHours(2)",
			"# while ((Test-ADTPowerPoint) -and (Get-Date) -lt \\$maxWaitTime) {",
			"#     Write-ADTLogEntry -Message 'PowerPoint präsentiert - warte 5 Minuten'",
			"#     Start-Sleep -Seconds 300",
			"# }$0"
		],
		"description": "Prüft ob PowerPoint in Präsentationsmodus läuft"
	},
	"Test-ADTRegistryValue": {
		"prefix": "testregistryvalue",
		"body": [
			"# Native: Test-Path -LiteralPath 'HKLM:\\\\SOFTWARE\\\\...' → Get-ItemProperty → \\$null -ne \\$_.Name",
			"<#",
			"  Verwendung: Prüft ob Registry-VALUE existiert (nicht nur Key!)",
			"  KRITISCH: Test-Path prüft nur KEYS! Diese Funktion prüft ob VALUE im Key existiert",
			"  Key: REQUIRED - Registry-Pfad (z.B. 'HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Session Manager')",
			"  Name: REQUIRED - Value-Name (z.B. 'PendingFileRenameOperations')",
			"  SID: Optional - Konvertiert HKCU zu HKEY_USERS\\\\SID (für andere User)",
			"  Wow6432Node: Optional - Prüft 32-bit Registry auf 64-bit System",
			"  Unterschied zu Test-Path:",
			"    - Test-Path: Prüft ob KEY existiert",
			"    - Test-ADTRegistryValue: Prüft ob VALUE in Key existiert",
			"  Kann auch leere/null Values erkennen (Test-Path kann das NICHT)",
			"  Nutzung: Prüfen ob bestimmte Registry-Einstellung gesetzt ist",
			"#>",
			"${1:\\$valueExists} = Test-ADTRegistryValue ``",
			"    -Key '${2:HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion}' ``",
			"    -Name '${3:ProgramFilesDir}' ``",
			"    ${4|#-SID 'S-1-5-21-...' ``,-SID \\$RunAsActiveUser.SID ``|}",
			"    ${5|#-Wow6432Node,-Wow6432Node|}",
			"",
			"# Beispiel: Prüfen ob reboot pending ist",
			"# \\$rebootPending = Test-ADTRegistryValue ``",
			"#     -Key 'HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Session Manager' ``",
			"#     -Name 'PendingFileRenameOperations'$0"
		],
		"description": "Prüft ob Registry-VALUE existiert (nicht nur Key)"
	},
	"Test-ADTServiceExists": {
		"prefix": "testserviceexists",
		"body": [
			"# Native: Get-Service -Name 'wuauserv' -ErrorAction SilentlyContinue",
			"<#",
			"  Verwendung: Prüft ob Windows-Service existiert (installiert ist)",
			"  KRITISCH: Prüft NUR ob Service installiert ist, NICHT ob er läuft!",
			"  Name: REQUIRED - Service-Name (z.B. 'wuauserv' für Windows Update)",
			"  UseCIM: Optional - Nutzt WMI/CIM statt Get-Service (PSADT v3.x Kompatibilität)",
			"  PassThru: Optional - Gibt ServiceController- oder CIM-Objekt zurück",
			"  Unterschiede:",
			"    - Get-Service (Standard): Schnell, funktioniert überall AUSSER Windows Sandbox",
			"    - CIM/WMI (UseCIM): Langsamer, funktioniert in Windows Sandbox, v3.x kompatibel",
			"  Bei UseCIM: Prüft Win32_Service UND Win32_BaseService (komplette Abdeckung)",
			"  Service-Name ≠ Display-Name! (z.B. 'wuauserv' ≠ 'Windows Update')",
			"  Nutzung: Prerequisite-Check vor Service-Start/Stop",
			"#>",
			"${1:\\$serviceExists} = Test-ADTServiceExists ``",
			"    -Name '${2:wuauserv}' ``",
			"    ${3|#-UseCIM ``,-UseCIM ``|}",
			"    ${4|#-PassThru,-PassThru|}",
			"",
			"# Beispiel: Service starten wenn vorhanden",
			"# if (Test-ADTServiceExists -Name 'wuauserv') {",
			"#     Start-ADTServiceAndDependencies -Name 'wuauserv'",
			"# }$0"
		],
		"description": "Prüft ob Windows-Service existiert"
	},
	"Test-ADTSessionActive": {
		"prefix": "testsessionactive",
		"body": [
			"# Native: Keine - prüft PSADT-interne Session-Verwaltung (\\$Script:ADT.Sessions.Count)",
			"<#",
			"  Verwendung: Prüft ob aktive PSADT-Session existiert",
			"  KRITISCH: Session = Open-ADTSession bis Close-ADTSession!",
			"  Benötigt KEINE Parameter - einzeilige Funktion",
			"  Gibt \\$true wenn mindestens EINE aktive Session existiert",
			"  Gibt \\$false wenn KEINE aktive Session existiert",
			"  Session wird erstellt durch: Open-ADTSession",
			"  Session wird geschlossen durch: Close-ADTSession",
			"  PSADT kann MEHRERE Sessions gleichzeitig haben (verschachtelt)",
			"  Nutzung: Prüfen ob bereits in Deployment-Context (Open-ADTSession aufgerufen)",
			"  Unterschied zu Test-ADTModuleInitialized:",
			"    - Test-ADTModuleInitialized: Modul geladen und initialisiert?",
			"    - Test-ADTSessionActive: Deployment-Session aktiv?",
			"#>",
			"${1:\\$hasSession} = Test-ADTSessionActive",
			"",
			"# Beispiel: Nur bei fehlender Session öffnen",
			"# if (-not (Test-ADTSessionActive)) {",
			"#     Open-ADTSession -DeploymentType 'Install'",
			"# }$0"
		],
		"description": "Prüft ob aktive PSADT-Session existiert"
	},
	"Test-ADTUserIsBusy": {
		"prefix": "testuserisbusy",
		"body": [
			"# Native: (Test-ADTMicrophoneInUse) -or (Get-ADTPresentationSettingsEnabledUsers) -or (Test-ADTPowerPoint)",
			"<#",
			"  Verwendung: Umfassender Check ob User beschäftigt ist (Mikrofon/Präsentation/PowerPoint)",
			"  KRITISCH: Kombiniert DREI Checks in EINEM - praktischer Wrapper!",
			"  Prüft automatisch:",
			"    1. Test-ADTMicrophoneInUse - Mikrofon aktiv? (Teams, Zoom, Recording)",
			"    2. Get-ADTPresentationSettingsEnabledUsers - Presentation Mode manuell aktiviert?",
			"    3. Test-ADTPowerPoint - PowerPoint präsentiert?",
			"  Gibt \\$true wenn IRGENDEINE Bedingung erfüllt ist (User ist beschäftigt)",
			"  Gibt \\$false wenn ALLE Bedingungen false sind (User ist NICHT beschäftigt)",
			"  Keine Parameter - vollautomatischer Check",
			"  Ideal für: Installation/Reboot verzögern wenn User arbeitet",
			"  ACHTUNG: Kann false negatives haben (z.B. Zoom ohne Mikrofon)",
			"  Nutzung: Deployment-Timing optimieren (User Experience)",
			"#>",
			"${1:\\$userBusy} = Test-ADTUserIsBusy",
			"",
			"# Beispiel: Installation verzögern wenn User beschäftigt (max 4 Stunden)",
			"# \\$maxWaitTime = (Get-Date).AddHours(4)",
			"# while ((Test-ADTUserIsBusy) -and (Get-Date) -lt \\$maxWaitTime) {",
			"#     Write-ADTLogEntry -Message 'User beschäftigt - warte 10 Minuten'",
			"#     Start-Sleep -Seconds 600",
			"# }$0"
		],
		"description": "Prüft ob User beschäftigt ist (Mikrofon/Präsentation/PowerPoint)"
	},
	"Unblock-ADTAppExecution": {
		"prefix": "unblockappexecution",
		"body": [
			"# Native: Remove-ItemProperty -Path \\\"HKLM:\\\\SOFTWARE\\\\...\\\\Image File Execution Options\\\\{exe}\\\" -Name 'Debugger'",
			"<#",
			"  Verwendung: Hebt Block-ADTAppExecution auf (erlaubt blockierte Apps wieder)",
			"  KRITISCH: Wird automatisch von Close-ADTSession aufgerufen - selten manuell nötig!",
			"  Tasks: Optional - Scheduled Tasks zum Entsperren (Standard: alle PSAppDeployToolkit_*_BlockedApps)",
			"  Entfernt:",
			"    - IFEO Debugger Registry-Keys (Image File Execution Options)",
			"    - Scheduled Tasks die blockierte Apps überwachen",
			"  Benötigt Admin-Rechte! Bei fehlendem Admin wird Funktion übersprungen",
			"  OnFinish Callback wird automatisch entfernt nach Ausführung",
			"  Gegenpart zu: Block-ADTAppExecution",
			"  Automatischer Cleanup auch bei Script-Fehler (Scheduled Task als Fallback)",
			"  Nutzung: Manuelles Entsperren wenn Close-ADTSession nicht aufgerufen wird",
			"#>",
			"Unblock-ADTAppExecution ${1|,'-Tasks \\$tasks'|}",
			"",
			"# Beispiel: Alle blockierten Apps entsperren",
			"# Unblock-ADTAppExecution",
			"",
			"# Beispiel: Nur spezifische Tasks entsperren",
			"# \\$tasks = Get-ScheduledTask -TaskName 'PSAppDeployToolkit_MyApp_BlockedApps'",
			"# Unblock-ADTAppExecution -Tasks \\$tasks$0"
		],
		"description": "Hebt Block-ADTAppExecution auf (entsperrt Apps)"
	},
	"Uninstall-ADTApplication": {
		"prefix": "uninstallapplication",
		"body": [
			"# Native: Get-ADTApplication | ForEach { msiexec.exe /x \\$_.ProductCode /qn } (nur MSI, sehr basic)",
			"<#",
			"  Verwendung: Deinstalliert Apps nach Name/ProductCode/FilterScript (MSI + EXE)",
			"  KRITISCH: Nutzt Get-ADTApplication zum Finden UND UninstallString zum Deinstallieren!",
			"  Zwei ParameterSets:",
			"    1. Search: -Name, -ProductCode, -FilterScript (sucht Apps)",
			"    2. InstalledApplication: Pipeline von Get-ADTApplication (bereits gefundene Apps)",
			"  Name: App-Name (Contains-Match, z.B. 'Adobe Acrobat')",
			"  FilterScript: Erweiterte Filter ({ \\$_.Publisher -match 'Adobe' -and \\$_.Is64BitApplication })",
			"  ArgumentList: Überschreibt UninstallString-Parameter komplett",
			"  AdditionalArgumentList: Fügt zu UninstallString-Parametern hinzu",
			"  MSI: Nutzt Start-ADTMsiProcess (Logging, Exit Codes, etc.)",
			"  EXE: Nutzt QuietUninstallString ODER UninstallString + Start-ADTProcess",
			"  Nutzung: Alte Versionen deinstallieren vor neuer Installation",
			"#>",
			"Uninstall-ADTApplication ``",
			"    -Name '${1:Adobe Acrobat}' ``",
			"    ${2|-NameMatch Contains,-NameMatch Exact,-NameMatch Wildcard,-NameMatch Regex|} ``",
			"    ${3|#-ApplicationType All ``,-ApplicationType MSI ``,-ApplicationType EXE ``|}",
			"    ${4|#-FilterScript { \\$_.Publisher -match 'Adobe' } ``,-FilterScript { \\$_.DisplayVersion -lt '20.0' } ``,-FilterScript { \\$_.Is64BitApplication -eq \\$false } ``|}",
			"    ${5|#-AdditionalArgumentList '/norestart' ``,-AdditionalArgumentList 'REBOOT=ReallySuppress' ``|}",
			"    ${6|#-PassThru,-PassThru|}",
			"",
			"# Beispiel: Alle alten Java-Versionen deinstallieren (außer 8.x), nur 64-bit",
			"# Uninstall-ADTApplication ``",
			"#     -Name 'Java' ``",
			"#     -FilterScript { \\$_.Publisher -eq 'Oracle Corporation' -and \\$_.Is64BitApplication -and \\$_.DisplayVersion -notlike '8.*' }",
			"",
			"# Beispiel: Via Pipeline",
			"# Get-ADTApplication -Name 'Old App' -NameMatch Exact | Uninstall-ADTApplication -PassThru$0"
		],
		"description": "Deinstalliert Apps nach Name/ProductCode/FilterScript"
	},
	"Unregister-ADTDll": {
		"prefix": "unregisterdll",
		"body": [
			"# Native: regsvr32.exe /u /s \\\"C:\\\\path\\\\to\\\\file.dll\\\"",
			"<#",
			"  Verwendung: Deregistriert DLL/OCX/ActiveX mit regsvr32.exe",
			"  KRITISCH: Nur für COM DLLs! Standard DLLs benötigen KEINE Registrierung",
			"  FilePath: REQUIRED - Pfad zur DLL (muss existieren, sonst Fehler)",
			"  Nutzt regsvr32.exe /u /s (unregister + silent)",
			"  Prüft automatisch ob Datei existiert vor Aufruf",
			"  COM DLLs = DLLs die Regsvr32-Funktionen DllRegisterServer/DllUnregisterServer exportieren",
			"  Typische Szenarien:",
			"    - ActiveX-Controls deregistrieren",
			"    - COM-Komponenten entfernen",
			"    - Legacy-Apps vor Deinstallation aufräumen",
			"  Gegenpart: Register-ADTDll (registriert DLL)",
			"  Nutzung: Alte COM-Komponenten vor Installation neuer Version entfernen",
			"#>",
			"Unregister-ADTDll -FilePath \\\"${1:C:\\\\Program Files\\\\MyApp\\\\MyComponent.dll}\\\"",
			"",
			"# Beispiel: DLL aus Files-Ordner deregistrieren",
			"# Unregister-ADTDll -FilePath \\\"\\$\\(\\$adtSession.DirFiles\\)\\\\old_component.dll\\\"$0"
		],
		"description": "Deregistriert DLL/OCX/ActiveX mit regsvr32.exe"
	},
	"Update-ADTDesktop": {
		"prefix": "updatedesktop",
		"body": [
			"# Native: Keine - erfordert SHChangeNotify Win32 API + SHCNE_ASSOCCHANGED",
			"<#",
			"  Verwendung: Aktualisiert Windows Explorer Desktop (Icons, Umgebungsvariablen neu laden)",
			"  KRITISCH: Benötigt angemeldeten User! Bei SYSTEM ohne User wird übersprungen",
			"  Keine Parameter - vollautomatischer Refresh",
			"  Aktualisiert:",
			"    - Desktop Icons (nach .lnk Änderungen)",
			"    - Datei-Assoziationen (nach Registry-Änderungen)",
			"    - Umgebungsvariablen im Explorer (nach PATH-Änderungen)",
			"  Nutzt PSADT Client/Server-Kommunikation (läuft als angemeldeter User)",
			"  ACHTUNG: Aktualisiert NICHT PowerShell Environment Vars! Nutze Update-ADTEnvironmentPsProvider",
			"  Typische Szenarien:",
			"    - Nach Set-ADTShortcut (neue Desktop-Icons sichtbar machen)",
			"    - Nach Set-ADTEnvironmentVariable (PATH in Explorer aktualisieren)",
			"    - Nach Set-ADTFileAssociation (neue Dateityp-Icons anzeigen)",
			"  Nutzung: Nach Änderungen die Desktop/Explorer betreffen",
			"#>",
			"Update-ADTDesktop",
			"",
			"# Beispiel: Nach Shortcut-Erstellung Desktop aktualisieren",
			"# Set-ADTShortcut -Path \\\"\\$envPublic\\\\Desktop\\\\MyApp.lnk\\\" -TargetPath \\\"\\$envProgramFiles\\\\MyApp\\\\App.exe\\\"",
			"# Update-ADTDesktop$0"
		],
		"description": "Aktualisiert Explorer Desktop (Icons/Umgebungsvariablen)"
	},
	"Update-ADTEnvironmentPsProvider": {
		"prefix": "updateenvironmentpsprovider",
		"body": [
			"# Native: \\$env:PATH = [Environment]::GetEnvironmentVariable('PATH','Machine') + ';' + [Environment]::GetEnvironmentVariable('PATH','User')",
			"<#",
			"  Verwendung: Aktualisiert PowerShell Environment-Variablen (\\$env:*) in aktueller Session",
			"  KRITISCH: Nur für PowerShell-Session! Desktop/Explorer nutzt Update-ADTDesktop",
			"  LoadLoggedOnUserEnvironmentVariables: DEPRECATED - wird in 4.2.0 entfernt",
			"  Lädt Environment-Variablen neu aus:",
			"    - HKLM:\\\\SYSTEM\\\\...\\\\Environment (Machine/System)",
			"    - HKCU:\\\\Environment (Current User)",
			"  PATH wird speziell behandelt: Machine + User kombiniert",
			"  Reihenfolge: SYSTEM zuerst, dann USER (User überschreibt System)",
			"  ACHTUNG: Ändert NUR PowerShell \\$env:*, NICHT:",
			"    - CMD Umgebungsvariablen",
			"    - Explorer Environment",
			"    - Andere Prozesse",
			"  Nutzung: Nach Set-ADTEnvironmentVariable in gleicher PowerShell-Session",
			"#>",
			"Update-ADTEnvironmentPsProvider",
			"",
			"# Beispiel: PATH-Variable setzen und sofort in PowerShell nutzen",
			"# Set-ADTEnvironmentVariable -Name 'PATH' -Value \\\"\\$env:PATH;C:\\\\MyApp\\\\bin\\\" -Target Machine",
			"# Update-ADTEnvironmentPsProvider",
			"# # Jetzt kann 'myapp.exe' direkt aufgerufen werden$0"
		],
		"description": "Aktualisiert PowerShell Environment-Variablen (\\$env:*)"
	},
	"Update-ADTGroupPolicy": {
		"prefix": "updateggrouppolicy",
		"body": [
			"# Native: gpupdate.exe /Target:Computer /Force ; gpupdate.exe /Target:User /Force",
			"<#",
			"  Verwendung: Erzwingt Group Policy Update (gpupdate /Force für Computer + User)",
			"  KRITISCH: ErrorAction = SilentlyContinue (Fehler werden geloggt aber nicht geworfen)",
			"  Keine Parameter - führt automatisch Computer + User Update durch",
			"  Nutzt cmd.exe + echo N (automatisch 'N' bei Reboot-Prompts)",
			"  Zwei separate Aufrufe:",
			"    1. gpupdate.exe /Target:Computer /Force",
			"    2. gpupdate.exe /Target:User /Force",
			"  Exit Code 0 = Erfolg, andere = Fehler (wird geloggt)",
			"  Dauer: Kann 30-60 Sekunden dauern (abhängig von Policies)",
			"  Typische Szenarien:",
			"    - Nach ADM/ADMX Registry-Änderungen",
			"    - Nach Domain GPO-Deployment",
			"    - Vor Software-Installation die Policy benötigt",
			"  Nutzung: Group Policies sofort anwenden (statt auf 90min Background Refresh warten)",
			"#>",
			"Update-ADTGroupPolicy",
			"",
			"# Beispiel: Nach Registry-Änderung Policy aktualisieren",
			"# Set-ADTRegistryKey -Key 'HKLM:\\\\SOFTWARE\\\\Policies\\\\...' -Name 'Setting' -Value 1",
			"# Update-ADTGroupPolicy$0"
		],
		"description": "Erzwingt Group Policy Update (gpupdate /Force)"
	},
	"Write-ADTLogEntry": {
		"prefix": "writelogentry",
		"body": [
			"# Native: Write-Host, Write-Verbose, Write-Information (keine CMTrace-Logs!)",
			"<#",
			"  Verwendung: Schreibt Logs in CMTrace-Format ODER Legacy-Text (wichtigste Logging-Funktion!)",
			"  KRITISCH: Kann MIT oder OHNE aktive Session verwendet werden!",
			"  Message: REQUIRED - Log-Nachricht (String oder Array über Pipeline)",
			"  Severity: Optional - Log-Level:",
			"    - 1 = Information (Standard, grün in CMTrace)",
			"    - 2 = Warning (gelb in CMTrace)",
			"    - 3 = Error (rot in CMTrace)",
			"  Source: Optional - Quelle (Funktionsname, z.B. \\$MyInvocation.MyCommand.Name)",
			"  ScriptSection: Optional - Abschnitt (z.B. 'Pre-Installation', 'Installation', 'Post-Installation')",
			"  LogType: Optional - CMTrace (Standard) oder Legacy (Textdatei)",
			"  HostLogStream: Optional - Konsolen-Output:",
			"    - None = Keine Konsolen-Ausgabe",
			"    - Information = Write-Information (Standard bei Severity 1)",
			"    - Warning = Write-Warning (Standard bei Severity 2)",
			"    - Error = Write-Error (Standard bei Severity 3)",
			"    - Verbose = Write-Verbose",
			"  DebugMessage: Debug-Logs (nur wenn \\$ToolkitOptions.LogDebugMessage = \\$true)",
			"  PassThru: Gibt LogEntry-Objekt zurück",
			"  Log-Pfad: Default = \\$envWinDir\\\\Logs\\\\PSAppDeployToolkit\\\\AppName_PSAppDeployToolkit_MM-DD-YYYY_HH-MM-SS.log",
			"#>",
			"Write-ADTLogEntry ``",
			"    -Message '${1:Installation wird gestartet...}' ``",
			"    ${2|-Severity 1,-Severity 2,-Severity 3|} ``",
			"    ${3|#-Source \\$MyInvocation.MyCommand.Name ``,-Source \\$MyInvocation.MyCommand.Name ``,-Source 'Custom-Function' ``|}",
			"    ${4|#-ScriptSection 'Pre-Installation' ``,-ScriptSection 'Pre-Installation' ``,-ScriptSection 'Installation' ``,-ScriptSection 'Post-Installation' ``|}",
			"    ${5|#-DebugMessage,-DebugMessage|}",
			"",
			"# Beispiele:",
			"",
			"# Info-Log (Standard)",
			"# Write-ADTLogEntry -Message 'Installation erfolgreich abgeschlossen'",
			"",
			"# Warning mit Source",
			"# Write-ADTLogEntry -Message 'Alter Treiber gefunden - wird überschrieben' -Severity 2 -Source \\$MyInvocation.MyCommand.Name",
			"",
			"# Error mit ScriptSection",
			"# Write-ADTLogEntry -Message 'Setup.exe nicht gefunden!' -Severity 3 -ScriptSection 'Installation'",
			"",
			"# Debug-Log (nur wenn LogDebugMessage = \\$true)",
			"# Write-ADTLogEntry -Message \\\"Variable \\$test = \\$test\\\" -DebugMessage",
			"",
			"# Pipeline-Nutzung",
			"# @('Schritt 1 abgeschlossen', 'Schritt 2 abgeschlossen') | Write-ADTLogEntry",
			"",
			"# Mit PassThru (Log-Objekt zurückgeben)",
			"# \\$logEntry = Write-ADTLogEntry -Message 'Wichtiger Schritt' -PassThru$0"
		],
		"description": "Schreibt Logs in CMTrace/Legacy-Format (wichtigste Logging-Funktion)"
	}
}